---
phase: 01-core-migration
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - app/api/import/trigger/route.ts
  - app/import/page.tsx
autonomous: true

must_haves:
  truths:
    - "User uploads ChatGPT export, Vercel authenticates and returns 202 Accepted in <5 seconds"
    - "Vercel /api/import/trigger endpoint only does auth + fire RLM + return (no heavy processing)"
    - "Frontend polls user_profiles.progress_percent to show real-time import progress"
    - "Frontend shows specific stage messages (Downloading, Parsing, Generating soulprint)"
  artifacts:
    - path: "app/api/import/trigger/route.ts"
      provides: "Thin authentication proxy that triggers RLM"
      exports: ["POST"]
      max_lines: 150
    - path: "app/import/page.tsx"
      provides: "Frontend with progress polling"
      contains: "progress_percent"
  key_links:
    - from: "app/api/import/trigger/route.ts"
      to: "RLM /import-full"
      via: "fetch POST with user_id and storage_path"
      pattern: "fetch.*import-full"
    - from: "app/import/page.tsx"
      to: "/api/import/trigger"
      via: "POST after chunked upload completes"
      pattern: "fetch.*trigger"
    - from: "app/import/page.tsx"
      to: "user_profiles.progress_percent"
      via: "polling interval"
      pattern: "progress_percent|import_stage"
---

<objective>
Create Vercel thin proxy endpoint and wire frontend to RLM streaming pipeline.

Purpose: Move all heavy processing to RLM, make Vercel a pure authentication + trigger layer that returns immediately.
Output: Working end-to-end flow from frontend → Vercel auth → RLM processing with real-time progress updates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-migration/01-RESEARCH.md
@app/api/import/queue-processing/route.ts
@app/import/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Create Vercel thin proxy endpoint /api/import/trigger</name>
  <files>app/api/import/trigger/route.ts</files>
  <action>
Create app/api/import/trigger/route.ts as a minimal authentication proxy:

```typescript
/**
 * Thin authentication proxy for import processing.
 * Authenticates user, triggers RLM /import-full, returns 202 immediately.
 *
 * NO heavy processing here - RLM handles download, parse, quick pass.
 */

import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createClient as createAdminClient } from '@supabase/supabase-js';
import { checkRateLimit } from '@/lib/rate-limit';
import { createLogger } from '@/lib/logger';

const log = createLogger('API:ImportTrigger');

export const runtime = 'nodejs';
export const maxDuration = 30; // 30 seconds max (just for auth + trigger)

function getSupabaseAdmin() {
  return createAdminClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    { auth: { autoRefreshToken: false, persistSession: false } }
  );
}

export async function POST(request: Request) {
  const adminSupabase = getSupabaseAdmin();
  const correlationId = request.headers.get('x-correlation-id') || undefined;
  const startTime = Date.now();

  try {
    // Auth check
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const reqLog = log.child({ correlationId, userId: user.id, endpoint: '/api/import/trigger' });

    // Rate limit check
    const rateLimited = await checkRateLimit(user.id, 'expensive');
    if (rateLimited) return rateLimited;

    const { storagePath } = await request.json();

    if (!storagePath) {
      return NextResponse.json({ error: 'storagePath required' }, { status: 400 });
    }

    reqLog.info({ storagePath }, 'Import trigger started');

    // Duplicate import guard (matching queue-processing.ts logic)
    const { data: existingProfile } = await adminSupabase
      .from('user_profiles')
      .select('import_status, processing_started_at')
      .eq('user_id', user.id)
      .single();

    if (existingProfile?.import_status === 'processing') {
      const startedAt = existingProfile.processing_started_at
        ? new Date(existingProfile.processing_started_at).getTime()
        : Date.now();
      const elapsedMs = Date.now() - startedAt;
      const elapsedMinutes = Math.round(elapsedMs / 1000 / 60);
      const STUCK_THRESHOLD_MS = 15 * 60 * 1000; // 15 minutes

      if (elapsedMs < STUCK_THRESHOLD_MS) {
        reqLog.warn({ elapsedMinutes }, 'Duplicate import rejected');
        return NextResponse.json(
          {
            error: 'Import already in progress. Please wait for it to complete.',
            status: 'processing',
            elapsedMinutes,
          },
          { status: 409 }
        );
      }

      reqLog.warn({ elapsedMinutes }, 'Stuck import detected, allowing retry');
    }

    // Update user profile to processing status
    await adminSupabase.from('user_profiles').upsert({
      user_id: user.id,
      import_status: 'processing',
      import_error: null,
      progress_percent: 0,
      import_stage: 'Starting...',
      processing_started_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    }, { onConflict: 'user_id' });

    // Fire RLM import (fire-and-forget, 10s timeout just to confirm acceptance)
    const rlmUrl = process.env.RLM_API_URL || 'https://soulprint-landing.onrender.com';

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);

      const rlmResponse = await fetch(`${rlmUrl}/import-full`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: user.id,
          storage_path: storagePath,
        }),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!rlmResponse.ok) {
        const errorText = await rlmResponse.text().catch(() => 'Unknown error');
        reqLog.error({ status: rlmResponse.status, error: errorText }, 'RLM returned error');

        await adminSupabase.from('user_profiles').update({
          import_status: 'failed',
          import_error: `RLM error: ${errorText.slice(0, 200)}`,
          updated_at: new Date().toISOString(),
        }).eq('user_id', user.id);

        return NextResponse.json({ error: 'Import service error' }, { status: 500 });
      }

      reqLog.info('RLM accepted job');
    } catch (e: unknown) {
      if (e instanceof Error && e.name === 'AbortError') {
        reqLog.warn('RLM job submission timed out (non-fatal)');
        // Don't fail - RLM may still process successfully
      } else {
        reqLog.error({ error: String(e) }, 'Failed to call RLM');

        await adminSupabase.from('user_profiles').update({
          import_status: 'failed',
          import_error: 'Failed to start import processing',
          updated_at: new Date().toISOString(),
        }).eq('user_id', user.id);

        return NextResponse.json({ error: 'Failed to start import' }, { status: 500 });
      }
    }

    const duration = Date.now() - startTime;
    reqLog.info({ duration, status: 202 }, 'Import triggered successfully');

    return NextResponse.json({
      success: true,
      status: 'processing',
      message: 'Import started. Processing on RLM service.',
    }, { status: 202 });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Failed to trigger import';
    const duration = Date.now() - startTime;

    log.error({ correlationId, duration, error: String(error) }, 'Import trigger failed');

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
```

**Key points:**
- maxDuration: 30 (was 300 in process-server - we only need auth + trigger)
- Duplicate import guard matching queue-processing.ts
- 10s timeout to confirm RLM accepted job (not full processing)
- Returns 202 immediately after RLM accepts
- Updates progress_percent: 0, import_stage: "Starting..." before triggering RLM
  </action>
  <verify>
Check that trigger endpoint exists and has correct structure:
```bash
grep -E "POST|import-full|202" /home/drewpullen/clawd/soulprint-landing/app/api/import/trigger/route.ts | head -5
```
  </verify>
  <done>/api/import/trigger endpoint created as thin proxy: auth → RLM fire → 202 response, maxDuration 30s</done>
</task>

<task type="auto">
  <name>Wire frontend to trigger endpoint with progress polling</name>
  <files>app/import/page.tsx</files>
  <action>
Update app/import/page.tsx to call /api/import/trigger and poll for progress updates.

**Changes needed:**

1. **After chunked upload completes**, replace queue-processing call with trigger call:

```typescript
// REPLACE this (queue-processing):
const response = await fetch('/api/import/queue-processing', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ storagePath, filename, fileSize, isExtracted }),
});

// WITH this (trigger):
const response = await fetch('/api/import/trigger', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ storagePath }),
});

if (response.status === 202) {
  // Import started - begin polling for progress
  startProgressPolling();
}
```

2. **Add progress polling function with useEffect cleanup**:

```typescript
const startProgressPolling = () => {
  const pollInterval = setInterval(async () => {
    try {
      const { data, error } = await supabase
        .from('user_profiles')
        .select('progress_percent, import_stage, import_status, import_error')
        .eq('user_id', user.id)
        .single();

      if (error) {
        console.error('Progress poll error:', error);
        return;
      }

      // Update UI with progress
      setProgress(data.progress_percent || 0);
      setStage(data.import_stage || 'Processing...');

      // Stop polling when complete or failed
      if (data.import_status === 'quick_ready' || data.import_status === 'failed') {
        clearInterval(pollInterval);

        if (data.import_status === 'quick_ready') {
          // Success - redirect to chat
          router.push('/chat');
        } else {
          // Failed - show error
          setError(data.import_error || 'Import failed');
        }
      }
    } catch (e) {
      console.error('Progress polling error:', e);
    }
  }, 2000); // Poll every 2 seconds

  // Store interval ID for cleanup
  return pollInterval;
};

// Add useEffect for cleanup on unmount
useEffect(() => {
  let pollInterval: NodeJS.Timeout | null = null;

  // If polling was started elsewhere, capture the interval ID
  // This is set when response.status === 202

  return () => {
    if (pollInterval) {
      clearInterval(pollInterval);
    }
  };
}, []);
```

3. **Add progress UI state**:

```typescript
const [progress, setProgress] = useState(0);
const [stage, setStage] = useState('');
```

4. **Update UI to show progress**:

```tsx
{stage && (
  <div className="mt-4">
    <div className="flex justify-between mb-2">
      <span className="text-sm text-gray-600">{stage}</span>
      <span className="text-sm text-gray-600">{progress}%</span>
    </div>
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div
        className="bg-blue-500 h-2 rounded-full transition-all duration-300"
        style={{ width: `${progress}%` }}
      />
    </div>
  </div>
)}
```

**Important:**
- Poll every 2 seconds (not too aggressive)
- Stop polling on 'quick_ready' or 'failed' status
- Show specific stage messages from import_stage column
- Clean up interval in useEffect on unmount (prevents memory leaks)
  </action>
  <verify>
Check that import page calls /api/import/trigger and has useEffect cleanup:
```bash
grep -E "import/trigger|progress_percent|import_stage" /home/drewpullen/clawd/soulprint-landing/app/import/page.tsx
grep -E "useEffect.*return.*clearInterval" /home/drewpullen/clawd/soulprint-landing/app/import/page.tsx || echo "WARNING: Missing useEffect cleanup wrapper"
```
  </verify>
  <done>Frontend updated to call /api/import/trigger, polls progress_percent and import_stage every 2s, shows progress bar with stage messages, includes useEffect cleanup to prevent memory leaks</done>
</task>

</tasks>

<verification>
1. /api/import/trigger endpoint exists and returns 202 after RLM accepts job
2. Frontend calls /api/import/trigger after upload completes
3. Frontend polls user_profiles for progress_percent and import_stage
4. Progress UI shows percentage and stage messages
5. Polling stops when import_status becomes 'quick_ready' or 'failed'
6. Vercel endpoint maxDuration is 30s (not 300s like old process-server)
7. useEffect cleanup wrapper properly clears polling interval on unmount
</verification>

<success_criteria>
- Vercel endpoint is a thin proxy (<30s execution, <5s typical)
- RLM handles all heavy processing (download, parse, quick pass)
- Frontend shows real-time progress (0% → 20% → 50% → 100%)
- Stage messages visible ("Downloading export", "Parsing conversations", "Generating soulprint")
- User redirected to /chat when import_status becomes 'quick_ready'
- Error displayed if import_status becomes 'failed'
- No memory leaks from polling interval (useEffect cleanup verified)
- Ready for Wave 4 end-to-end testing
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-migration/01-04-SUMMARY.md`
</output>
