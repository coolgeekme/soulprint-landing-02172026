---
phase: 02-memory-resource-cleanup
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/api/ttl-cache.ts
  - lib/api/ttl-cache.test.ts
  - app/api/import/chunked-upload/route.ts
  - app/api/import/chunked-upload/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Stale upload chunks are automatically removed after 30-minute TTL"
    - "Active uploads within TTL are not affected by cleanup"
    - "Expired entries return undefined on access (lazy deletion)"
    - "Background cleanup runs without blocking serverless process exit"
  artifacts:
    - path: "lib/api/ttl-cache.ts"
      provides: "Generic TTL cache with lazy deletion and background cleanup"
      exports: ["TTLCache"]
      contains: "unref"
    - path: "lib/api/ttl-cache.test.ts"
      provides: "TTL cache unit tests with fake timers"
      contains: "vi.useFakeTimers"
    - path: "app/api/import/chunked-upload/route.ts"
      provides: "Chunked upload using TTLCache instead of bare Map"
      contains: "TTLCache"
  key_links:
    - from: "app/api/import/chunked-upload/route.ts"
      to: "lib/api/ttl-cache.ts"
      via: "import TTLCache"
      pattern: "import.*TTLCache.*from.*ttl-cache"
    - from: "lib/api/ttl-cache.ts"
      to: "setInterval"
      via: "background cleanup with .unref()"
      pattern: "setInterval.*unref"
---

<objective>
Implement a TTL-based cache for chunked upload storage and replace the bare Map that currently leaks memory on abandoned uploads.

Purpose: BUG-01 requires chunked uploads to clean up stale chunks after 30 minutes. The current bare Map in `chunked-upload/route.ts` grows unboundedly when users abandon uploads mid-stream.

Output: A tested TTLCache class integrated into the chunked upload route, with both lazy deletion (on access) and proactive background cleanup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-resource-cleanup/02-RESEARCH.md
@app/api/import/chunked-upload/route.ts
</context>

<feature>
  <name>TTL Cache with Background Cleanup</name>
  <files>lib/api/ttl-cache.ts, lib/api/ttl-cache.test.ts, app/api/import/chunked-upload/route.ts, app/api/import/chunked-upload/route.test.ts</files>
  <behavior>
    TTLCache is a generic Map-based cache with time-to-live expiration.

    Core behaviors:
    - `set(key, value)` stores an entry with default TTL (30 minutes)
    - `set(key, value, customTTL)` stores with custom TTL
    - `get(key)` returns value if not expired, undefined if expired or missing
    - `get(key)` on expired entry deletes it (lazy deletion)
    - `delete(key)` removes immediately (for completed uploads)
    - `size` returns count of entries (including expired not yet cleaned)
    - `forceCleanup()` runs cleanup immediately and returns count removed
    - `destroy()` clears all data and stops background timer

    Background cleanup:
    - Runs on configurable interval (default 5 minutes)
    - Removes all entries past their TTL
    - Timer uses `.unref()` so it does not block serverless exit

    Test cases:
    - set + get within TTL -> returns value
    - set + advance past TTL + get -> returns undefined
    - set + advance 29min + get -> returns value (boundary)
    - set + advance 30min + get -> returns undefined (boundary)
    - set + advance past TTL + forceCleanup -> returns cleaned count > 0
    - set 2 entries, advance past TTL, cleanup -> size becomes 0
    - concurrent entries with different keys don't collide
    - delete(key) removes immediately regardless of TTL
    - destroy() clears everything and stops timer

    Chunked upload integration:
    - Replace `chunkStore = new Map<>()` with `new TTLCache<UploadSession>(30 * 60 * 1000, 5 * 60 * 1000)`
    - On completed upload: call `delete(uploadId)` (immediate cleanup on success)
    - All existing upload logic preserved (chunk indexing, assembly, Supabase upload)
  </behavior>
  <implementation>
    1. RED phase: Write tests for TTLCache class using `vi.useFakeTimers()` and `vi.advanceTimersByTime()`. Write test for chunked upload route integration using TTLCache. Tests must fail (class doesn't exist yet).

    2. GREEN phase: Implement TTLCache in `lib/api/ttl-cache.ts`:
       - Generic class `TTLCache<T>` with Map<string, { value: T; expiresAt: number }>
       - Constructor takes (defaultTTL: number, cleanupInterval: number)
       - `set(key, value, ttl?)`, `get(key)`, `delete(key)`, `has(key)`
       - `size` getter, `forceCleanup()`, `destroy()`
       - Background cleanup via `setInterval` with `.unref()`
       - Lazy deletion in `get()`: if `Date.now() > entry.expiresAt`, delete and return undefined

       Then update `chunked-upload/route.ts`:
       - Import TTLCache from `@/lib/api/ttl-cache`
       - Define UploadSession interface: `{ chunks: Buffer[]; totalChunks: number; receivedChunks: number }`
       - Replace `const chunkStore = new Map<...>()` with `const uploadCache = new TTLCache<UploadSession>(30 * 60 * 1000, 5 * 60 * 1000)`
       - Replace `chunkStore.has/get/set/delete` calls with `uploadCache.has/get/set/delete`
       - Remove the placeholder `cleanupStaleUploads` function (TTLCache handles this now)
       - Keep the existing error handling pattern (try-catch returning JSON error)

    3. REFACTOR phase: If any cleanup needed, do it. Ensure tests still pass.
  </implementation>
</feature>

<verification>
1. `npx vitest run lib/api/ttl-cache.test.ts` - all TTL cache tests pass
2. `npx vitest run app/api/import/chunked-upload/route.test.ts` - integration test passes
3. `npx vitest run` - full test suite still passes (no regressions)
4. `npm run build` - TypeScript compiles without errors
</verification>

<success_criteria>
- TTLCache class exported from lib/api/ttl-cache.ts with full test coverage
- Chunked upload route uses TTLCache instead of bare Map
- Expired entries (>30 min) return undefined on get()
- Background cleanup timer uses .unref() for serverless safety
- All tests pass, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-resource-cleanup/02-01-SUMMARY.md`
</output>
