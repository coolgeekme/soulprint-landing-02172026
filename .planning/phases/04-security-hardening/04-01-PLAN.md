---
phase: 04-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - middleware.ts
  - lib/supabase/middleware.ts
  - next.config.ts
autonomous: true

must_haves:
  truths:
    - "POST/PUT/DELETE requests without a valid CSRF token receive 403 Forbidden"
    - "GET requests pass through without CSRF validation"
    - "CSP and Permissions-Policy headers are present on all responses"
    - "Existing Supabase auth session refresh continues to work"
  artifacts:
    - path: "middleware.ts"
      provides: "CSRF middleware integrated with Supabase auth"
      contains: "createCsrfMiddleware"
    - path: "next.config.ts"
      provides: "CSP and Permissions-Policy security headers"
      contains: "Permissions-Policy"
  key_links:
    - from: "middleware.ts"
      to: "lib/supabase/middleware.ts"
      via: "CSRF runs before auth session update"
      pattern: "csrfMiddleware.*updateSession"
    - from: "next.config.ts"
      to: "all responses"
      via: "headers() config"
      pattern: "Content-Security-Policy"
---

<objective>
Add CSRF protection to all state-changing API endpoints via @edge-csrf/nextjs middleware, and add missing security headers (CSP, Permissions-Policy) to next.config.ts.

Purpose: Prevent cross-site request forgery attacks on POST/PUT/DELETE endpoints and strengthen browser-level security with Content-Security-Policy and Permissions-Policy headers.
Output: Updated middleware.ts with CSRF validation, updated next.config.ts with CSP + Permissions-Policy headers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-security-hardening/04-RESEARCH.md
@middleware.ts
@lib/supabase/middleware.ts
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @edge-csrf/nextjs and integrate CSRF middleware</name>
  <files>middleware.ts, lib/supabase/middleware.ts</files>
  <action>
1. Install @edge-csrf/nextjs: `npm install @edge-csrf/nextjs`

2. Update `middleware.ts` to integrate CSRF protection BEFORE Supabase auth:

```typescript
import { createCsrfMiddleware } from '@edge-csrf/nextjs';
import { type NextRequest, NextResponse } from 'next/server';
import { updateSession } from '@/lib/supabase/middleware';

const csrfMiddleware = createCsrfMiddleware({
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  },
});

export async function middleware(request: NextRequest) {
  // Apply CSRF protection (validates token on POST/PUT/DELETE, sets cookie on GET)
  const csrfResponse = await csrfMiddleware(request);

  // If CSRF validation failed, return 403 immediately
  if (csrfResponse.status === 403) {
    return csrfResponse;
  }

  // Pass through to Supabase auth session refresh
  // Transfer CSRF cookie from csrfResponse to the auth response
  const authResponse = await updateSession(request);

  // Copy CSRF cookies to auth response
  csrfResponse.cookies.getAll().forEach(cookie => {
    authResponse.cookies.set(cookie.name, cookie.value, {
      ...cookie,
    });
  });

  // Copy CSRF token header to auth response (for Server Components to read)
  const csrfToken = csrfResponse.headers.get('X-CSRF-Token');
  if (csrfToken) {
    authResponse.headers.set('X-CSRF-Token', csrfToken);
  }

  return authResponse;
}
```

Keep the existing matcher config unchanged.

IMPORTANT: The @edge-csrf/nextjs library uses the Double Submit Cookie pattern. It automatically:
- Sets a CSRF cookie on GET requests
- Validates the CSRF token on POST/PUT/DELETE requests (from header or body)
- Returns 403 if validation fails

Do NOT store CSRF tokens in localStorage (XSS vulnerability per research).

3. Update `lib/supabase/middleware.ts` - no changes needed, it already returns a NextResponse that we can append cookies to.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript/build errors. Then verify the middleware exports are correct.
  </verify>
  <done>CSRF middleware is integrated. POST/PUT/DELETE requests without valid CSRF token get 403. GET requests pass through and receive CSRF cookie.</done>
</task>

<task type="auto">
  <name>Task 2: Add CSP and Permissions-Policy security headers</name>
  <files>next.config.ts</files>
  <action>
Update `next.config.ts` headers() to add Content-Security-Policy and Permissions-Policy. Keep existing headers (X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, Referrer-Policy).

Add these headers:

```typescript
{
  key: 'Permissions-Policy',
  value: 'camera=(), microphone=(), geolocation=()',
},
{
  key: 'Content-Security-Policy',
  value: [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'",  // unsafe-inline needed for Next.js
    "style-src 'self' 'unsafe-inline'",  // unsafe-inline needed for Tailwind
    "img-src 'self' data: blob: https:",  // Allow external images
    "font-src 'self' data:",
    "connect-src 'self' https://swvljsixpvvcirjmflze.supabase.co https://soulprint-landing.onrender.com https://*.upstash.io",  // Supabase + RLM + Upstash
    "frame-ancestors 'none'",  // Redundant with X-Frame-Options but belt-and-suspenders
  ].join('; '),
},
```

NOTE: Using 'unsafe-inline' for scripts is necessary because Next.js App Router injects inline scripts for hydration. A nonce-based CSP would require dynamic middleware (per research, Pitfall 5). This is acceptable for now and can be tightened later.

Also keep the existing X-XSS-Protection header but note it's deprecated in modern browsers (CSP replaces it).
  </action>
  <verify>
Run `npm run build` to confirm no config errors. After deploy, check response headers with: `curl -I https://soulprint-landing.vercel.app` -- should see Content-Security-Policy and Permissions-Policy headers.
  </verify>
  <done>CSP and Permissions-Policy headers configured. All responses include defense-in-depth security headers.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Middleware correctly chains CSRF -> Auth
3. Security headers present in next.config.ts headers() output
4. CSRF cookie name visible in middleware logic
</verification>

<success_criteria>
- POST requests without CSRF token return 403
- GET requests set CSRF cookie and pass through to auth
- Response headers include Content-Security-Policy with connect-src for Supabase/RLM
- Response headers include Permissions-Policy restricting camera/mic/geo
- Existing auth flow (login, session refresh) unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-01-SUMMARY.md`
</output>
