---
phase: 04-security-hardening
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - lib/api/schemas.ts
  - app/api/chat/route.ts
  - app/api/chat/messages/route.ts
  - app/api/memory/query/route.ts
  - app/api/memory/delete/route.ts
  - app/api/import/complete/route.ts
  - app/api/waitlist/route.ts
  - app/api/profile/ai-name/route.ts
  - app/api/push/subscribe/route.ts
autonomous: true

must_haves:
  truths:
    - "Invalid request bodies return 400 with human-readable error message"
    - "Valid request bodies are parsed into typed objects (no manual type assertions)"
    - "Malformed JSON returns 400 (not 500)"
    - "Validation happens BEFORE any database queries or AI calls"
  artifacts:
    - path: "lib/api/schemas.ts"
      provides: "Centralized Zod schemas for all validated API routes"
      contains: "z.object"
    - path: "app/api/chat/route.ts"
      provides: "Chat endpoint with Zod-validated request body"
      contains: "safeParse"
    - path: "app/api/chat/messages/route.ts"
      provides: "Messages endpoint with Zod-validated request body"
      contains: "safeParse"
  key_links:
    - from: "lib/api/schemas.ts"
      to: "zod"
      via: "import { z } from 'zod'"
      pattern: "from 'zod'"
    - from: "app/api/chat/route.ts"
      to: "lib/api/schemas.ts"
      via: "import schema"
      pattern: "from '@/lib/api/schemas'"
    - from: "app/api/chat/messages/route.ts"
      to: "lib/api/schemas.ts"
      via: "import schema"
      pattern: "from '@/lib/api/schemas'"
---

<objective>
Add Zod validation schemas for all critical user-facing API routes. Create centralized schemas in lib/api/schemas.ts and integrate safeParse into route handlers for fail-fast validation before any database or AI calls.

Purpose: Prevent invalid/malicious input from reaching database queries and AI services. Provides type-safe parsed data (replacing manual `as` casts) and returns clear 400 errors instead of cryptic 500s.
Output: Centralized Zod schemas, 8 API routes updated with safeParse validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-security-hardening/04-RESEARCH.md
@app/api/chat/route.ts
@app/api/chat/messages/route.ts
@app/api/memory/query/route.ts
@app/api/memory/delete/route.ts
@app/api/import/complete/route.ts
@app/api/waitlist/route.ts
@app/api/profile/ai-name/route.ts
@app/api/push/subscribe/route.ts
@lib/api/error-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create centralized Zod schemas and validation helper</name>
  <files>lib/api/schemas.ts</files>
  <action>
1. Zod is already in the dependency tree (check package.json). If not present, install: `npm install zod`

2. Create `lib/api/schemas.ts` with schemas for each validated route:

```typescript
import { z } from 'zod';

// ============================================
// Chat Schemas
// ============================================

const chatMessageSchema = z.object({
  role: z.enum(['user', 'assistant']),
  content: z.string().min(1).max(100000),
});

export const chatRequestSchema = z.object({
  message: z.string().min(1, 'Message is required').max(50000),
  history: z.array(chatMessageSchema).max(100).default([]),
  voiceVerified: z.boolean().default(true),
  deepSearch: z.boolean().default(false),
});

export const saveMessageSchema = z.object({
  role: z.enum(['user', 'assistant'], {
    errorMap: () => ({ message: 'Role must be "user" or "assistant"' }),
  }),
  content: z.string().min(1, 'Content is required').max(100000, 'Message too long (max 100,000 chars)'),
});

// ============================================
// Memory Schemas
// ============================================

export const memoryQuerySchema = z.object({
  query: z.string().min(1, 'Query is required').max(5000),
  topK: z.number().int().min(1).max(50).default(5),
  includeFacts: z.boolean().default(false),
});

export const memoryDeleteSchema = z.object({
  chunkIds: z.array(z.string().uuid()).min(1, 'At least one chunk ID required').max(100),
});

// ============================================
// Import Schemas
// ============================================

export const importCompleteSchema = z.object({
  importId: z.string().min(1).optional(),
  status: z.enum(['complete', 'failed']).optional(),
  error: z.string().max(1000).optional(),
});

// ============================================
// Profile Schemas
// ============================================

export const aiNameSchema = z.object({
  name: z.string().min(1, 'Name is required').max(30, 'Name too long (max 30 chars)').trim(),
});

// ============================================
// Waitlist Schemas
// ============================================

export const waitlistSchema = z.object({
  email: z.string().email('Invalid email address').max(255),
  name: z.string().min(1).max(100).optional(),
  source: z.string().max(100).optional(),
});

// ============================================
// Push Subscription Schema
// ============================================

export const pushSubscribeSchema = z.object({
  endpoint: z.string().url('Invalid endpoint URL'),
  keys: z.object({
    p256dh: z.string().min(1),
    auth: z.string().min(1),
  }),
  expirationTime: z.number().nullable().optional(),
});

// ============================================
// Validation Helper
// ============================================

/**
 * Parse and validate a request body against a Zod schema.
 * Returns either the validated data or a 400 Response.
 *
 * Usage:
 *   const result = await parseRequestBody(request, chatRequestSchema);
 *   if (result instanceof Response) return result; // Validation failed
 *   const { message, history } = result; // Typed data
 */
export async function parseRequestBody<T extends z.ZodType>(
  request: Request,
  schema: T
): Promise<z.infer<T> | Response> {
  let body: unknown;

  try {
    body = await request.json();
  } catch {
    return new Response(
      JSON.stringify({ error: 'Invalid JSON in request body', code: 'INVALID_JSON' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  const result = schema.safeParse(body);

  if (!result.success) {
    // Convert Zod errors to human-readable message
    // Do NOT expose raw Zod error details (security: schema disclosure)
    const issues = result.error.issues.map(i => i.message).join('; ');
    return new Response(
      JSON.stringify({ error: issues, code: 'VALIDATION_ERROR' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  return result.data;
}
```

Key decisions:
- Use safeParse (not parse) per research anti-patterns -- avoids uncaught exceptions
- Error messages are human-readable but do NOT expose schema structure
- parseRequestBody helper handles both JSON parsing errors and validation errors
- Schemas define reasonable limits (message lengths, array sizes) to prevent abuse
- Default values via .default() for optional fields
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript errors. Verify the file exports all schemas and the parseRequestBody helper.
  </verify>
  <done>Centralized Zod schemas created for chat, messages, memory, import, profile, waitlist, and push subscribe routes. parseRequestBody helper provides ergonomic validation pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Zod validation into all critical API routes</name>
  <files>app/api/chat/route.ts, app/api/chat/messages/route.ts, app/api/memory/query/route.ts, app/api/memory/delete/route.ts, app/api/import/complete/route.ts, app/api/waitlist/route.ts, app/api/profile/ai-name/route.ts, app/api/push/subscribe/route.ts</files>
  <action>
For each route, replace the manual `await request.json()` + manual validation with the `parseRequestBody` helper.

**Pattern for each route:**

Before (typical):
```typescript
const body = await request.json();
const { message, history = [] } = body as { message: string; history?: ChatMessage[] };
if (!message || typeof message !== 'string') {
  return Response.json({ error: 'Message is required' }, { status: 400 });
}
```

After:
```typescript
import { parseRequestBody, chatRequestSchema } from '@/lib/api/schemas';
// ...
const result = await parseRequestBody(request, chatRequestSchema);
if (result instanceof Response) return result;
const { message, history, voiceVerified, deepSearch } = result;
```

**Specific routes to update:**

a) `app/api/chat/route.ts` POST handler:
   - Import: `chatRequestSchema`, `parseRequestBody`
   - Replace the `const body = await request.json()` block and the manual `if (!message ...)` check
   - Remove the `as { ... }` type assertion -- Zod provides the type
   - Keep the rest of the route handler unchanged

b) `app/api/chat/messages/route.ts` POST handler:
   - Import: `saveMessageSchema`, `parseRequestBody`
   - Replace the `const body = await request.json()` + `validRoles` check + `typeof content` check
   - Remove manual MAX_MESSAGE_LENGTH check (Zod handles it: `.max(100000)`)
   - Keep the GET handler unchanged (it only uses URL params, no body)

c) `app/api/memory/query/route.ts` POST handler:
   - Import: `memoryQuerySchema`, `parseRequestBody`
   - Replace `const body = await request.json()` + `if (!query ...)` check

d) `app/api/memory/delete/route.ts` POST handler:
   - Import: `memoryDeleteSchema`, `parseRequestBody`
   - Read the current implementation first to understand the expected body shape
   - Replace manual body parsing with schema validation

e) `app/api/import/complete/route.ts` POST handler:
   - Import: `importCompleteSchema`, `parseRequestBody`
   - Read the current implementation first to understand the expected body shape
   - Replace manual body parsing with schema validation
   - Note: This route may accept empty bodies or minimal data -- schema has all fields optional

f) `app/api/waitlist/route.ts` POST handler:
   - Import: `waitlistSchema`, `parseRequestBody`
   - Replace manual email validation with Zod

g) `app/api/profile/ai-name/route.ts` POST handler:
   - Import: `aiNameSchema`, `parseRequestBody`
   - Replace manual name validation with Zod

h) `app/api/push/subscribe/route.ts` POST handler:
   - Import: `pushSubscribeSchema`, `parseRequestBody`
   - Replace manual subscription validation with Zod

IMPORTANT: For each route, READ the existing code first to understand:
1. The exact body shape expected
2. Any manual validation that can be removed
3. Any post-parse logic that depends on specific field names

If the existing schema in the schemas.ts doesn't match what the route actually expects, UPDATE schemas.ts to match the real API contract. The schema must reflect reality, not ideals.

Do NOT change the response format, error handling, or business logic of any route. Only replace input parsing/validation.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript errors. Run `npm test` to ensure existing tests still pass. Grep all 8 routes for `parseRequestBody` to confirm integration.
  </verify>
  <done>All 8 critical API routes validate request bodies with Zod schemas before processing. Invalid input returns 400 with descriptive error. Malformed JSON returns 400 (not 500). All manual type assertions replaced with Zod-inferred types.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npm test` passes (existing tests unbroken)
3. All 8 routes import from `@/lib/api/schemas`
4. All 8 routes use `parseRequestBody` pattern
5. Manual `as { ... }` type assertions removed from validated routes
6. Manual `typeof x === 'string'` checks removed (Zod handles it)
</verification>

<success_criteria>
- Sending malformed JSON to any validated route returns 400 with "Invalid JSON" message
- Sending missing required fields returns 400 with descriptive Zod error
- Sending valid data works exactly as before (no behavior changes)
- No route exposes raw Zod error schema details in responses
- All schemas enforce reasonable limits (max lengths, max array sizes)
- Zod-inferred types replace manual `as` casts
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-04-SUMMARY.md`
</output>
