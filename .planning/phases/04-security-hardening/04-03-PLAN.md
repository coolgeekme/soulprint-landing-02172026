---
phase: 04-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/rls-audit.sql
  - scripts/rls-remediate.sql
autonomous: true

must_haves:
  truths:
    - "All Supabase tables in public schema have RLS enabled"
    - "Each user-data table has policies restricting access to the owning user"
    - "RLS audit query can be re-run to verify status at any time"
  artifacts:
    - path: "scripts/rls-audit.sql"
      provides: "SQL query to check RLS status of all public tables"
      contains: "pg_tables"
    - path: "scripts/rls-remediate.sql"
      provides: "SQL statements to enable RLS and create policies for unprotected tables"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "scripts/rls-audit.sql"
      to: "Supabase pg_tables"
      via: "SQL query"
      pattern: "rowsecurity"
    - from: "scripts/rls-remediate.sql"
      to: "Supabase tables"
      via: "ALTER TABLE and CREATE POLICY"
      pattern: "auth\\.uid\\(\\)"
---

<objective>
Audit all Supabase tables for RLS status, create remediation SQL for any unprotected tables, and produce reusable audit/remediation scripts.

Purpose: Ensure all user data is protected at the database level. Tables created via SQL (not Supabase dashboard) may have RLS disabled by default, exposing data to unauthorized access. This is a critical security gap (170+ Lovable apps were breached due to missing RLS in Jan 2025).
Output: RLS audit script, remediation script with ENABLE RLS + policies for all user-data tables.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-security-hardening/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS audit SQL script</name>
  <files>scripts/rls-audit.sql</files>
  <action>
Create `scripts/rls-audit.sql` with queries to check RLS status of all tables in the public schema.

```sql
-- RLS Audit Script for SoulPrint
-- Run in Supabase SQL Editor to check RLS status of all tables
-- Any table showing 'RLS DISABLED' is a security risk

-- 1. Check RLS status of all public tables
SELECT
  c.relname AS table_name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relrowsecurity THEN 'OK - RLS Enabled'
    ELSE 'SECURITY RISK - RLS DISABLED'
  END AS status
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'public'
  AND c.relkind = 'r'  -- ordinary tables only
ORDER BY c.relrowsecurity ASC, c.relname;

-- 2. List all existing RLS policies
SELECT
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual AS using_expression,
  with_check
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- 3. Tables with RLS enabled but NO policies (effectively locked out)
SELECT c.relname AS table_name
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_policies p ON p.tablename = c.relname AND p.schemaname = 'public'
WHERE n.nspname = 'public'
  AND c.relkind = 'r'
  AND c.relrowsecurity = true
  AND p.policyname IS NULL;
```

This script is safe to run (read-only queries against system catalogs). It produces 3 result sets:
1. RLS status of every table
2. All existing policies
3. Tables with RLS on but no policies (potential lockout)
  </action>
  <verify>
File exists at `scripts/rls-audit.sql` and contains the 3 audit queries. SQL syntax is valid PostgreSQL.
  </verify>
  <done>RLS audit script created. Can be run in Supabase SQL Editor to check all tables.</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS remediation SQL script</name>
  <files>scripts/rls-remediate.sql</files>
  <action>
Create `scripts/rls-remediate.sql` with SQL to enable RLS and create policies for the known SoulPrint tables.

Based on the codebase, the tables that store user data are:
- `user_profiles` - User profiles with soulprint data (key: user_id)
- `conversation_chunks` - Memory chunks (key: user_id)
- `chat_messages` - Chat history (key: user_id)

Additional tables may exist. The script should be idempotent (safe to run multiple times).

```sql
-- RLS Remediation Script for SoulPrint
-- Run in Supabase SQL Editor to enable RLS and create policies
-- This script is IDEMPOTENT - safe to run multiple times

-- ============================================
-- user_profiles
-- ============================================
ALTER TABLE IF EXISTS public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Users can read their own profile
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'user_profiles' AND policyname = 'Users can view own profile'
  ) THEN
    CREATE POLICY "Users can view own profile"
    ON public.user_profiles
    FOR SELECT
    USING (auth.uid() = user_id);
  END IF;
END $$;

-- Users can update their own profile
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'user_profiles' AND policyname = 'Users can update own profile'
  ) THEN
    CREATE POLICY "Users can update own profile"
    ON public.user_profiles
    FOR UPDATE
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- Users can insert their own profile (for first-time setup)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'user_profiles' AND policyname = 'Users can insert own profile'
  ) THEN
    CREATE POLICY "Users can insert own profile"
    ON public.user_profiles
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- ============================================
-- conversation_chunks
-- ============================================
ALTER TABLE IF EXISTS public.conversation_chunks ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'conversation_chunks' AND policyname = 'Users can view own chunks'
  ) THEN
    CREATE POLICY "Users can view own chunks"
    ON public.conversation_chunks
    FOR SELECT
    USING (auth.uid() = user_id);
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'conversation_chunks' AND policyname = 'Users can insert own chunks'
  ) THEN
    CREATE POLICY "Users can insert own chunks"
    ON public.conversation_chunks
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'conversation_chunks' AND policyname = 'Users can delete own chunks'
  ) THEN
    CREATE POLICY "Users can delete own chunks"
    ON public.conversation_chunks
    FOR DELETE
    USING (auth.uid() = user_id);
  END IF;
END $$;

-- ============================================
-- chat_messages
-- ============================================
ALTER TABLE IF EXISTS public.chat_messages ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'chat_messages' AND policyname = 'Users can view own messages'
  ) THEN
    CREATE POLICY "Users can view own messages"
    ON public.chat_messages
    FOR SELECT
    USING (auth.uid() = user_id);
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'chat_messages' AND policyname = 'Users can insert own messages'
  ) THEN
    CREATE POLICY "Users can insert own messages"
    ON public.chat_messages
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);
  END IF;
END $$;

-- ============================================
-- IMPORTANT NOTES
-- ============================================
-- 1. Service role key BYPASSES RLS. API routes using createAdminClient
--    with SUPABASE_SERVICE_ROLE_KEY will still work for server-side operations.
-- 2. Do NOT use auth.jwt()->>'user_metadata' in RLS policies (can be spoofed).
--    Always use auth.uid() which is cryptographically verified.
-- 3. After running, re-run scripts/rls-audit.sql to verify all tables are protected.
-- 4. Index columns used in RLS policies for performance:
--    These tables should already have indexes on user_id.
```

IMPORTANT: The project uses `SUPABASE_SERVICE_ROLE_KEY` (admin client) in many API routes. The service role key bypasses RLS entirely, so existing server-side operations will NOT break. RLS only affects requests made with the anon key or user JWT.

The script uses `DO $$ ... END $$` blocks to check for existing policies before creating them, making it idempotent.
  </action>
  <verify>
File exists at `scripts/rls-remediate.sql`. Contains `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` for all 3 user-data tables. Contains `CREATE POLICY` statements that use `auth.uid() = user_id`. All policy creation is wrapped in idempotent `IF NOT EXISTS` checks.
  </verify>
  <done>RLS remediation script created for user_profiles, conversation_chunks, and chat_messages. Script is idempotent and safe to run multiple times. Service role operations unaffected.</done>
</task>

</tasks>

<verification>
1. `scripts/rls-audit.sql` exists with 3 audit queries
2. `scripts/rls-remediate.sql` exists with ENABLE RLS + policies for all user-data tables
3. All policies use `auth.uid() = user_id` (not user_metadata)
4. Remediation script is idempotent (IF NOT EXISTS checks)
5. Notes about service role key bypass are present
</verification>

<success_criteria>
- RLS audit script can be run in Supabase SQL Editor without errors
- Remediation script enables RLS on user_profiles, conversation_chunks, chat_messages
- Each table has SELECT, INSERT, UPDATE, and/or DELETE policies as appropriate
- All policies use auth.uid() for user identification
- Existing API routes using service role key continue to work (service role bypasses RLS)
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-03-SUMMARY.md`
</output>
