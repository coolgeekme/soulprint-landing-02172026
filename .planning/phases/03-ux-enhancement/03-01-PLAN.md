---
phase: 03-ux-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/memory/status/route.ts
  - app/import/page.tsx
autonomous: true

must_haves:
  truths:
    - "User sees RingProgress circle with real percentage during import processing (not a generic spinner)"
    - "User sees stage-specific labels ('Downloading your export', 'Reading conversations', 'Building your profile') that change as RLM progresses"
    - "User who returns to tab after 5+ minutes sees current progress immediately (not stale data)"
    - "User who closes browser and returns to import page sees real progress_percent from database (not hardcoded 60%)"
  artifacts:
    - path: "app/import/page.tsx"
      provides: "Stage-aware processing UI with RingProgress, visibility polling, real returning-user progress"
      contains: "RingProgress"
    - path: "app/api/memory/status/route.ts"
      provides: "progress_percent and import_stage in API response"
      contains: "progress_percent"
  key_links:
    - from: "app/import/page.tsx"
      to: "app/api/memory/status/route.ts"
      via: "checkExisting fetch reads progress_percent and import_stage for returning users"
      pattern: "progress_percent"
    - from: "app/import/page.tsx"
      to: "user_profiles table"
      via: "direct Supabase polling reads progress_percent and import_stage every 2s"
      pattern: "supabase.*from.*user_profiles.*select.*progress_percent"
    - from: "app/import/page.tsx"
      to: "components/ui/ring-progress.tsx"
      via: "RingProgress component renders real progress percentage"
      pattern: "<RingProgress"
---

<objective>
Replace the generic spinner in the import processing step with a stage-aware progress UI that shows real percentage via RingProgress and stage-specific labels. Add visibility-aware polling so background tabs recover immediately when focused. Fix returning-user progress to read real values from the database instead of hardcoded 60%.

Purpose: Users currently see a spinning icon and generic text during import processing with no sense of how far along it is. Returning users see hardcoded 60% progress. Background tabs show stale data after Chrome throttles timers.

Output: Processing step shows RingProgress with real percentage, stage labels match RLM stages, tab visibility triggers immediate poll, returning users see real progress.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ux-enhancement/03-RESEARCH.md

@app/import/page.tsx
@app/api/memory/status/route.ts
@components/ui/ring-progress.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress fields to memory status API and build stage-aware processing UI</name>
  <files>app/api/memory/status/route.ts, app/import/page.tsx</files>
  <action>
**Part A: Memory Status API (app/api/memory/status/route.ts)**

Add `progress_percent` and `import_stage` to the select query and response JSON:

1. In the `.select()` call (line 23), add `progress_percent, import_stage` to the comma-separated field list
2. In the `NextResponse.json()` response object (around line 51), add these two fields:
   ```
   progress_percent: profile?.progress_percent ?? 0,
   import_stage: profile?.import_stage ?? null,
   ```

**Part B: Stage configuration and processing UI (app/import/page.tsx)**

1. Add a stage configuration constant ABOVE the `ImportPageContent` component (after the `safeJsonParse` function, around line 42):

```typescript
// Import stage configuration — maps RLM import_stage strings to user-facing labels
const IMPORT_STAGES = [
  { key: 'downloading', match: /download/i, label: 'Downloading your export', threshold: 0 },
  { key: 'parsing', match: /pars/i, label: 'Reading conversations', threshold: 20 },
  { key: 'generating', match: /generat|soulprint/i, label: 'Building your profile', threshold: 50 },
  { key: 'complete', match: /complete/i, label: 'Analysis complete!', threshold: 100 },
] as const;

function getCurrentStageLabel(importStage: string): string {
  const stage = IMPORT_STAGES.find(s => s.match.test(importStage));
  return stage?.label ?? 'Processing...';
}
```

2. Replace the PROCESSING STEP section (lines 869-908, the `{currentStep === 'processing' && status !== 'error' && (...)}` block) with a stage-aware version:

- Replace the spinner icon div (the `Loader2 animate-spin` inside the rounded-full bg) with the `RingProgress` component:
  ```tsx
  <RingProgress
    progress={progress}
    size={80}
    strokeWidth={6}
    showPercentage={true}
  />
  ```
- Replace the hardcoded heading "Analyzing your conversations..." (line 883) with:
  ```tsx
  <h2 className="text-lg sm:text-xl font-bold text-white mb-1 sm:mb-2">
    {getCurrentStageLabel(progressStage)}
  </h2>
  ```
- Replace the generic `progressStage` text below the heading (line 884) with stage indicator dots showing completed/current/upcoming stages:
  ```tsx
  <div className="flex items-center justify-center gap-3 mt-3">
    {IMPORT_STAGES.slice(0, -1).map((stage, i) => {
      const nextThreshold = IMPORT_STAGES[i + 1]?.threshold ?? 100;
      const isComplete = progress >= nextThreshold;
      const isCurrent = !isComplete && progress >= stage.threshold;
      return (
        <div key={stage.key} className="flex items-center gap-3">
          <div className={`w-2.5 h-2.5 rounded-full transition-colors duration-300 ${
            isComplete ? 'bg-green-500' :
            isCurrent ? 'bg-orange-500 animate-pulse' :
            'bg-white/20'
          }`} />
          {i < IMPORT_STAGES.length - 2 && (
            <div className={`w-6 h-0.5 transition-colors duration-300 ${isComplete ? 'bg-green-500' : 'bg-white/10'}`} />
          )}
        </div>
      );
    })}
  </div>
  ```
- Update the "don't close" message (lines 886-890) to use a smarter threshold. After upload completes (progress >= 55), show "Safe to close this tab" in green. Before that, keep the current warning:
  ```tsx
  {progress >= 55 ? (
    <p className="text-green-400/80 text-xs mt-3">
      Safe to close this tab — processing continues in the background
    </p>
  ) : (
    <p className="text-orange-400/80 text-xs mt-3">
      Please keep this tab open until upload completes
    </p>
  )}
  ```
- Keep the existing progress bar (the gradient div, lines 892-899) — it complements the ring nicely
- Keep the Cancel button

**Important:** The `RingProgress` component is already imported on line 10 (`import { RingProgress } from '@/components/ui/ring-progress'`). No new import needed.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no TypeScript errors
2. Run `npm run lint` — no linting errors
3. Read the memory/status route and confirm `progress_percent` and `import_stage` are in both the select query and the response JSON
4. Read import/page.tsx and confirm:
   - IMPORT_STAGES constant exists with 4 stages
   - Processing step uses `<RingProgress` instead of `<Loader2 className="animate-spin"`
   - Stage heading uses `getCurrentStageLabel(progressStage)` instead of hardcoded text
   - Stage dots are rendered with completed/current/upcoming states
  </verify>
  <done>
Memory status API returns progress_percent and import_stage. Processing step shows RingProgress with real percentage, stage-specific heading, and stage indicator dots instead of generic spinner.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add visibility-aware polling and fix returning-user progress</name>
  <files>app/import/page.tsx</files>
  <action>
**Part A: Visibility-aware polling for active import**

Add a `visibilitychange` event listener that immediately polls when the tab becomes visible. This handles Chrome's background tab timer throttling (60s intervals after 5 minutes hidden).

1. Inside the `processFile` function, AFTER the `progressIntervalRef.current = setInterval(...)` block that polls every 2 seconds (around line 541), add a visibility change handler:

```typescript
// Immediate poll when tab becomes visible (Chrome throttles background intervals to 60s)
const handleVisibilityChange = () => {
  if (document.visibilityState === 'visible' && progressIntervalRef.current) {
    // Re-poll immediately when user returns to tab
    (async () => {
      try {
        const { data, error } = await supabase
          .from('user_profiles')
          .select('progress_percent, import_stage, import_status, import_error')
          .eq('user_id', user.id)
          .single();
        if (error || !data) return;
        setProgress(data.progress_percent || 0);
        setProgressStage(data.import_stage || 'Processing...');
        if (data.import_status === 'quick_ready' || data.import_status === 'complete') {
          if (progressIntervalRef.current) {
            clearInterval(progressIntervalRef.current);
            progressIntervalRef.current = null;
          }
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          setProgress(100);
          setProgressStage('Analysis complete! Opening chat...');
          await new Promise(r => setTimeout(r, 800));
          router.push('/chat');
        } else if (data.import_status === 'failed') {
          if (progressIntervalRef.current) {
            clearInterval(progressIntervalRef.current);
            progressIntervalRef.current = null;
          }
          document.removeEventListener('visibilitychange', handleVisibilityChange);
          setErrorMessage(data.import_error || 'Import failed');
          setStatus('error');
        }
      } catch (e) {
        console.error('[Import] Visibility poll error:', e);
      }
    })();
  }
};
document.addEventListener('visibilitychange', handleVisibilityChange);
```

2. Also clean up the visibility listener when the polling interval is cleared. In the two places where `progressIntervalRef.current` is cleared inside the setInterval callback (the success branch around line 520-528 and the failure branch around line 529-536), add `document.removeEventListener('visibilitychange', handleVisibilityChange)` after the clearInterval.

HOWEVER, since `handleVisibilityChange` is defined after the setInterval, the cleanest approach is: store the handler in a ref or use the component unmount cleanup. Add to the existing cleanup useEffect (lines 107-112):
```typescript
// In the cleanup useEffect at the top of the component, add:
return () => {
  if (uploadProgressIntervalRef.current) clearInterval(uploadProgressIntervalRef.current);
  if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
};
```
This already exists. The visibility listener cleanup happens naturally when the interval is cleared (the handler checks `progressIntervalRef.current` before acting). This is acceptable since the handler is a no-op when the interval is null.

Actually, for proper cleanup, store the handler reference. Add a new ref at the top of the component alongside the other refs:
```typescript
const visibilityHandlerRef = useRef<(() => void) | null>(null);
```

Then in processFile, assign it:
```typescript
visibilityHandlerRef.current = handleVisibilityChange;
document.addEventListener('visibilitychange', handleVisibilityChange);
```

And update the cleanup useEffect:
```typescript
return () => {
  if (uploadProgressIntervalRef.current) clearInterval(uploadProgressIntervalRef.current);
  if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
  if (visibilityHandlerRef.current) {
    document.removeEventListener('visibilitychange', visibilityHandlerRef.current);
    visibilityHandlerRef.current = null;
  }
};
```

**Part B: Fix returning-user progress recovery**

In the `checkExisting` useEffect (lines 141-237), fix the `data.status === 'processing'` branch (lines 190-218):

1. Replace the hardcoded `setProgress(60)` (line 193) with: `setProgress(data.progress_percent ?? 0)`
2. Replace the hardcoded `setProgressStage('Processing your conversations...')` (line 194) with: `setProgressStage(data.import_stage ?? 'Processing...')`

These fields are now available because Task 1 added them to the `/api/memory/status` response.

3. Also add a visibility change handler for the returning-user polling path. Inside the `data.status === 'processing'` branch, after the setInterval setup (line 217), add:
```typescript
// Visibility-aware polling for returning users too
const handleReturnVisibility = () => {
  if (document.visibilityState === 'visible' && progressIntervalRef.current) {
    // Immediate poll on tab focus
    fetch('/api/memory/status').then(r => r.json()).then(pollData => {
      if (pollData.progress_percent !== undefined) setProgress(pollData.progress_percent);
      if (pollData.import_stage) setProgressStage(pollData.import_stage);
      if (pollData.status === 'ready' || pollData.hasSoulprint) {
        if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
        setProgress(100);
        setProgressStage('Analysis complete! Opening chat...');
        setTimeout(() => router.push('/chat'), 800);
      } else if (pollData.status === 'failed' || pollData.failed) {
        if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
        setErrorMessage(pollData.import_error || 'Processing failed. Please try again.');
        setStatus('error');
      }
    }).catch(() => {});
  }
};
document.addEventListener('visibilitychange', handleReturnVisibility);
visibilityHandlerRef.current = handleReturnVisibility;
```

Also update the returning-user polling interval (the setInterval at line 198) to read progress_percent and import_stage from the poll response and update the UI:
After `const pollData = await pollRes.json();` add:
```typescript
// Update progress from real data
if (pollData.progress_percent !== undefined) setProgress(pollData.progress_percent);
if (pollData.import_stage) setProgressStage(pollData.import_stage);
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no TypeScript errors
2. Run `npm run lint` — no linting errors
3. Read import/page.tsx and confirm:
   - `visibilityHandlerRef` exists as a ref
   - Cleanup useEffect removes the visibility listener
   - processFile adds a `visibilitychange` listener after setting up the polling interval
   - `checkExisting` uses `data.progress_percent ?? 0` instead of hardcoded 60
   - `checkExisting` uses `data.import_stage ?? 'Processing...'` instead of hardcoded string
   - Returning-user polling also updates progress_percent and import_stage from poll data
  </verify>
  <done>
Background tab recovery works via Page Visibility API — immediate poll on tab focus. Returning users see real progress from the database instead of hardcoded 60%. Both the active-import and returning-user polling paths update progress_percent and import_stage in real time.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run lint` passes
3. Processing step renders `<RingProgress` component (not `<Loader2 className="animate-spin"`)
4. Stage heading displays stage-specific text based on `import_stage` from RLM
5. Memory status API response includes `progress_percent` and `import_stage`
6. Returning user polling reads real `progress_percent` from memory/status (not hardcoded 60)
7. `visibilitychange` event listener exists for immediate polling on tab focus
</verification>

<success_criteria>
- Processing step shows RingProgress ring with real percentage and stage-specific labels
- Background tab returns show fresh progress immediately (no stale 60%)
- Returning users see actual import progress from database
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-ux-enhancement/03-01-SUMMARY.md`
</output>
