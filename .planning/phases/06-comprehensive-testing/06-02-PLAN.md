---
phase: 06-comprehensive-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/integration/api/import/process-server.test.ts
  - tests/integration/api/import/chunked-upload.test.ts
  - tests/integration/api/import/complete.test.ts
autonomous: true

must_haves:
  truths:
    - "Import process-server test covers the full upload-to-processing pipeline"
    - "Chunked upload test verifies multi-chunk assembly and single-chunk upload"
    - "Import complete test verifies email notification trigger and profile lookup"
    - "All import tests mock Supabase storage, RLM, and auth - no real external calls"
  artifacts:
    - path: "tests/integration/api/import/process-server.test.ts"
      provides: "Import processing integration tests"
      min_lines: 60
    - path: "tests/integration/api/import/chunked-upload.test.ts"
      provides: "Chunked upload integration tests"
      min_lines: 40
    - path: "tests/integration/api/import/complete.test.ts"
      provides: "Import completion callback tests"
      min_lines: 40
  key_links:
    - from: "tests/integration/api/import/process-server.test.ts"
      to: "app/api/import/process-server/route.ts"
      via: "testApiHandler import"
      pattern: "import.*from.*app/api/import/process-server"
    - from: "tests/integration/api/import/complete.test.ts"
      to: "app/api/import/complete/route.ts"
      via: "testApiHandler import"
      pattern: "import.*from.*app/api/import/complete"
---

<objective>
Write integration tests for the import flow API routes: process-server, chunked-upload, and complete.

Purpose: Satisfies TEST-02 (import flow has end-to-end test coverage: upload -> process -> complete) at the integration test level. The import pipeline is the most critical and complex flow in the application, involving file uploads, ZIP parsing, Supabase storage, and RLM service calls.

Output: 3 integration test files covering auth, validation, happy paths, and error states for the entire import pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-comprehensive-testing/06-RESEARCH.md

@app/api/import/process-server/route.ts
@app/api/import/chunked-upload/route.ts
@app/api/import/complete/route.ts
@tests/setup.ts
@tests/mocks/handlers.ts
@lib/api/schemas.ts
@lib/api/error-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures and write import process-server tests</name>
  <files>
    tests/mocks/fixtures/sample-conversations.json
    tests/integration/api/import/process-server.test.ts
  </files>
  <action>
1. Create `tests/mocks/fixtures/sample-conversations.json` -- a minimal valid ChatGPT export array with 2-3 conversations. Must have the `mapping` structure that process-server validates:
   ```json
   [
     {
       "id": "conv-1",
       "title": "Test Conversation",
       "create_time": 1700000000,
       "mapping": {
         "node-1": {
           "message": {
             "author": { "role": "user" },
             "content": { "parts": ["Hello, how are you?"] }
           }
         },
         "node-2": {
           "message": {
             "author": { "role": "assistant" },
             "content": { "parts": ["I'm doing well, thanks!"] }
           }
         }
       }
     }
   ]
   ```
   Keep it minimal but valid (2-3 conversations, 2-4 messages each).

2. Write `tests/integration/api/import/process-server.test.ts`:

   Mocking strategy:
   - Mock `@/lib/supabase/server` createClient for auth
   - Mock `@supabase/supabase-js` createClient for admin operations (storage download, profile upsert)
   - Mock `@/lib/rate-limit` checkRateLimit to return null
   - Mock `@/lib/logger` to suppress log output
   - Use MSW to intercept the RLM `/process-full` POST call
   - Mock `zlib` gzipSync to return a buffer (skip actual compression)

   Test cases:
   - "returns 401 when not authenticated" -- no auth headers, no X-Internal-User-Id. Assert 401.
   - "returns 400 when storagePath missing" -- authenticated but body has no storagePath. Assert 400.
   - "accepts internal server-to-server calls via X-Internal-User-Id header" -- set header, mock storage download to return valid JSON fixture. Assert 200 with success:true.
   - "processes valid JSON file successfully" -- mock storage.download to return the sample-conversations fixture as a Blob/ArrayBuffer. Assert response includes success:true, totalConversations > 0, totalMessages > 0.
   - "rejects invalid ChatGPT format" -- mock storage.download to return `[{"no_mapping": true}]`. Assert 500 with error containing "doesn't look like a ChatGPT export".
   - "handles storage download failure" -- mock storage.download to return error. Assert 500.
   - "fires RLM process-full call" -- verify MSW intercepted the /process-full POST.

   Key implementation detail: The route calls `request.json()` for the body and `adminSupabase.storage.from(...).download(...)` for the file. Mock the admin supabase client to return controlled responses for both storage operations and profile upserts.
  </action>
  <verify>
    `npx vitest run tests/integration/api/import/process-server.test.ts` -- all tests pass.
  </verify>
  <done>Process-server integration tests cover auth, validation, successful processing, invalid format rejection, and storage failures. All external calls mocked.</done>
</task>

<task type="auto">
  <name>Task 2: Write chunked-upload and import-complete integration tests</name>
  <files>
    tests/integration/api/import/chunked-upload.test.ts
    tests/integration/api/import/complete.test.ts
  </files>
  <action>
**chunked-upload.test.ts** - Test POST /api/import/chunked-upload:

Mocking strategy:
- Mock `@/lib/supabase/server` createClient for auth (return mock with auth.getUser)
- Mock `@/lib/rate-limit` checkRateLimit to return null
- Mock `@/lib/logger` to suppress output
- Mock Supabase storage.upload to return success

Test cases:
- "returns 401 when not authenticated" -- assert 401
- "accepts single chunk and returns complete" -- send request with X-Chunk-Index: 0, X-Total-Chunks: 1, body as ArrayBuffer. Assert response has complete: true, path exists.
- "accumulates multiple chunks" -- send chunk 0 of 2, assert complete: false, received: 1. Then send chunk 1 of 2, assert complete: true.
- "handles storage upload error" -- mock storage.upload to return error. Assert 500.

Note: chunked-upload.test.ts tests the route handler's logic for chunk assembly. The TTLCache is already tested in lib/api/ttl-cache.test.ts, so focus on the HTTP layer.

**complete.test.ts** - Test POST /api/import/complete:

Mocking strategy:
- Mock `@/lib/api/error-handler` handleAPIError
- Mock `@/lib/email` sendEmail to return { success: true }
- Mock `@/lib/rate-limit` checkRateLimit to return null
- Mock `@supabase/supabase-js` createClient for admin operations

Test cases:
- "returns 404 when user profile not found" -- mock supabase query to return error. Assert 404.
- "validates request body with Zod" -- send empty body. Assert 400.
- "sends email notification on completion" -- mock profile found, mock auth.admin.getUserById returns user with email. Assert response has email_sent: true. Verify sendEmail was called.
- "handles missing user email gracefully" -- mock auth.admin.getUserById returns user without email. Assert email_sent: false.
- "accepts progressive availability params" -- send {user_id, soulprint_ready: true, memory_building: true}. Assert success.

Key: The import-complete route is called by RLM (server-to-server), not by the browser. It doesn't use cookie auth -- it takes user_id in the body. Test it accordingly.
  </action>
  <verify>
    `npx vitest run tests/integration/api/import/` -- all import integration tests pass.
    `npx vitest run` -- ALL tests pass, no regressions.
  </verify>
  <done>Chunked-upload tests cover auth, single/multi-chunk assembly, and storage errors. Import-complete tests cover validation, email notification, and progressive availability. The full import pipeline (upload -> process -> complete) is covered by integration tests.</done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/integration/api/import/` passes with 0 failures
2. `npx vitest run` full suite passes (existing + all new integration tests)
3. Import flow tested end-to-end at integration level: chunked-upload -> process-server -> complete
4. All tests run offline with no external calls
</verification>

<success_criteria>
- Process-server tested for auth, valid/invalid file processing, RLM call
- Chunked-upload tested for single and multi-chunk assembly
- Import-complete tested for email notification trigger and validation
- Test fixtures created for realistic ChatGPT export data
- All tests offline, all pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-comprehensive-testing/06-02-SUMMARY.md`
</output>
