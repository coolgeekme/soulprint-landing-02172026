---
phase: 06-comprehensive-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/integration/api/health.test.ts
  - tests/integration/api/chat-messages.test.ts
  - tests/integration/api/memory-status.test.ts
  - tests/mocks/handlers.ts
autonomous: true

must_haves:
  truths:
    - "Health endpoint integration test verifies healthy, degraded, and down states"
    - "Chat messages endpoint tests verify auth, GET pagination, and POST with Zod validation"
    - "Memory status endpoint test verifies response shape for different import states"
    - "All integration tests run offline with no external API calls"
  artifacts:
    - path: "tests/integration/api/health.test.ts"
      provides: "Health endpoint integration tests"
      min_lines: 40
    - path: "tests/integration/api/chat-messages.test.ts"
      provides: "Chat messages GET/POST integration tests"
      min_lines: 50
    - path: "tests/integration/api/memory-status.test.ts"
      provides: "Memory status endpoint integration tests"
      min_lines: 30
  key_links:
    - from: "tests/integration/api/health.test.ts"
      to: "app/api/health/route.ts"
      via: "next-test-api-route-handler import"
      pattern: "import.*from.*app/api/health/route"
    - from: "tests/mocks/handlers.ts"
      to: "all integration tests"
      via: "MSW server intercepts"
      pattern: "server\\.use|handlers"
---

<objective>
Write integration tests for core API routes using next-test-api-route-handler and MSW.

Purpose: Satisfies TEST-03 (all API routes have integration tests with mocked dependencies) for the core, non-import API routes: health, chat/messages, and memory/status. These routes represent the critical data paths for the chat experience.

Output: 3 integration test files covering auth checks, validation, happy paths, and error states. Extended MSW handlers for Supabase mocking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-comprehensive-testing/06-RESEARCH.md

@app/api/health/route.ts
@app/api/chat/messages/route.ts
@app/api/memory/status/route.ts
@tests/setup.ts
@tests/mocks/handlers.ts
@tests/mocks/server.ts
@vitest.config.mts
@lib/api/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install next-test-api-route-handler and extend MSW handlers</name>
  <files>
    package.json
    tests/mocks/handlers.ts
  </files>
  <action>
1. Install next-test-api-route-handler as a dev dependency:
   `npm install -D next-test-api-route-handler`

2. Extend `tests/mocks/handlers.ts` with Supabase REST API mock handlers needed for integration tests:
   - Mock `NEXT_PUBLIC_SUPABASE_URL/rest/v1/profiles` (GET, returns test profile data)
   - Mock `NEXT_PUBLIC_SUPABASE_URL/rest/v1/user_profiles` (GET, returns test user profile)
   - Mock `NEXT_PUBLIC_SUPABASE_URL/rest/v1/chat_messages` (GET returns messages array, POST returns inserted message)
   - Mock `NEXT_PUBLIC_SUPABASE_URL/auth/v1/user` (GET, returns authenticated test user)
   - Keep existing RLM handlers intact
   - Use a test Supabase URL constant (e.g., `https://test.supabase.co`) and set it as env var in tests

3. Also mock `next/headers` in tests/setup.ts if not already done (needed for createClient in route handlers). Add:
   ```
   vi.mock('@/lib/supabase/server', () => ({
     createClient: vi.fn()
   }))
   ```
   This allows per-test control of auth state.

4. Set required env vars in vitest.config.mts via `env` option or in tests/setup.ts:
   - `NEXT_PUBLIC_SUPABASE_URL=https://test.supabase.co`
   - `SUPABASE_SERVICE_ROLE_KEY=test-service-role-key`
   - `RLM_SERVICE_URL=https://soulprint-landing.onrender.com`
   - `AWS_ACCESS_KEY_ID=test-key`
   - `AWS_SECRET_ACCESS_KEY=test-secret`
   - `BEDROCK_MODEL_ID=test-model`

Note: next-test-api-route-handler emulates the Next.js request/response environment, making it possible to test App Router route handlers without running a full Next.js server. This is the recommended approach from the research phase.
  </action>
  <verify>
    `npm ls next-test-api-route-handler` shows package installed.
    `npx vitest run` -- existing 48 tests still pass (no regressions from handler changes).
  </verify>
  <done>next-test-api-route-handler installed, MSW handlers extended with Supabase mocks, env vars configured for test environment, existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for health, chat/messages, and memory/status routes</name>
  <files>
    tests/integration/api/health.test.ts
    tests/integration/api/chat-messages.test.ts
    tests/integration/api/memory-status.test.ts
  </files>
  <action>
Create `tests/integration/api/` directory and write the following test files:

**health.test.ts** - Test GET /api/health:
- "returns healthy when all dependencies OK" -- MSW default handlers return 200 for RLM, mock Supabase query success, env vars set for Bedrock. Assert response.status === 200, body.status === 'healthy', all 3 dependencies present.
- "returns degraded when RLM returns 500" -- use `server.use()` to override RLM handler with 500 response. Assert body.status contains 'degraded' or 'down', rlm dependency shows unhealthy.
- "returns down when RLM unreachable" -- override RLM handler to throw network error. Assert status is 503 or body.status is 'down'.
- Mock `@/lib/logger` to prevent Pino from attempting to write during tests (use `vi.mock('@/lib/logger', ...)`).
- Use `testApiHandler({ appHandler: import('app/api/health/route') })` pattern.

**chat-messages.test.ts** - Test GET and POST /api/chat/messages:
- Mock `@/lib/supabase/server` createClient to return a mock supabase client with controllable auth.getUser() responses.
- "GET returns 401 when not authenticated" -- mock auth to return no user. Assert 401.
- "GET returns messages array for authenticated user" -- mock auth to return test user, mock supabase query to return sample messages. Assert 200, body.messages is array.
- "POST returns 401 when not authenticated" -- Assert 401.
- "POST validates message body with Zod" -- Send invalid body (empty content). Assert 400, body.code === 'VALIDATION_ERROR'.
- "POST saves valid message" -- Send valid {role: 'user', content: 'hello'}. Assert 200, body.message exists.
- Mock `@/lib/rate-limit` checkRateLimit to return null (no rate limiting in tests).

**memory-status.test.ts** - Test GET /api/memory/status:
- "returns status 'none' when no profile" -- mock auth success, mock supabase query to return PGRST116 error (not found). Assert body.status === 'none'.
- "returns status 'ready' when import complete" -- mock profile with import_status='complete'. Assert body.status === 'ready', body.hasSoulprint === true.
- "returns status 'processing' when importing" -- mock profile with import_status='processing'. Assert body.status === 'processing'.
- "returns stats when profile exists" -- assert body.stats has totalConversations and totalMessages.

Important patterns:
- Use `vi.mock()` for module mocks (supabase, logger, rate-limit)
- Use `server.use()` for per-test MSW overrides (RLM, external HTTP)
- Each test file should import the route handler via `import * as appHandler from '@/app/api/...'`
- Clear mocks in afterEach to prevent test pollution
  </action>
  <verify>
    `npx vitest run tests/integration/` -- all integration tests pass.
    `npx vitest run` -- ALL tests pass (existing + new), no regressions.
    Total test count should increase by 10+ new tests.
  </verify>
  <done>Integration tests pass for health (3 tests), chat/messages (5 tests), and memory/status (4 tests). All tests run offline with MSW intercepting all external requests. Total test count has increased significantly.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` passes with 0 failures
2. `npx vitest run tests/integration/` runs only integration tests, all pass
3. No network requests escape MSW (onUnhandledRequest: 'error' in setup.ts)
4. Test count has increased by 10+ from baseline of 48
</verification>

<success_criteria>
- Health endpoint tested for healthy/degraded/down states
- Chat messages tested for auth, validation, GET/POST operations
- Memory status tested for all import_status values
- All tests run offline in under 30 seconds
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-comprehensive-testing/06-01-SUMMARY.md`
</output>
