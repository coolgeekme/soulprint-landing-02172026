---
phase: 03-wire-new-endpoint
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - /home/drewpullen/clawd/soulprint-rlm/tests/test_endpoints.py
  - /home/drewpullen/clawd/soulprint-rlm/ROLLBACK.md
autonomous: true

must_haves:
  truths:
    - "All existing production endpoints return non-500 status codes when called via TestClient"
    - "/process-full-v2 endpoint returns 200 with version=v2 and job_id"
    - "/process-full-v2 returns 400 when storage_path is missing"
    - "/health endpoint returns processors_available=true"
    - "Rollback procedure is documented with git revert commands"
  artifacts:
    - path: "/home/drewpullen/clawd/soulprint-rlm/tests/test_endpoints.py"
      provides: "Integration tests for all endpoints including v2"
      min_lines: 80
    - path: "/home/drewpullen/clawd/soulprint-rlm/ROLLBACK.md"
      provides: "Rollback procedure documentation"
      contains: "git revert"
  key_links:
    - from: "test_endpoints.py"
      to: "main.app"
      via: "FastAPI TestClient"
      pattern: "from main import app"
    - from: "test_endpoints.py"
      to: "all endpoints"
      via: "parametrized endpoint tests"
      pattern: "process-full-v2"
---

<objective>
Verify backwards compatibility of all existing endpoints after the lifespan migration and v2 endpoint addition, and document the rollback procedure.

Purpose: This is the safety net for Phase 3. The endpoint tests prove that the lifespan migration and v2 endpoint addition did not break any of the 15 existing endpoints. The rollback doc provides a concrete recovery procedure if issues are found in production.

Output: test_endpoints.py with integration tests, ROLLBACK.md with git revert procedure.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-wire-new-endpoint/03-RESEARCH.md
@.planning/phases/03-wire-new-endpoint/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write endpoint integration tests for backwards compatibility</name>
  <files>/home/drewpullen/clawd/soulprint-rlm/tests/test_endpoints.py</files>
  <action>
Create tests/test_endpoints.py that verifies all endpoints respond correctly after the lifespan migration.

**IMPORTANT CONTEXT:** main.py uses module-level variables (SUPABASE_URL, SUPABASE_SERVICE_KEY, etc.) and the lifespan does processor import validation + startup tasks (resume_stuck_jobs, check incomplete embeddings) that make HTTP calls to Supabase. The TestClient will trigger the lifespan, so external HTTP calls need to be handled.

**Approach:** Use pytest-httpx to mock all external HTTP calls that happen during startup (lifespan) and during endpoint calls. The TestClient triggers lifespan on first request.

**Test structure:**

```python
"""
Integration tests for endpoint backwards compatibility.
Verifies all existing endpoints still work after lifespan migration and v2 addition.
"""
import pytest
from fastapi.testclient import TestClient


@pytest.fixture
def client(httpx_mock):
    """
    Create TestClient with mocked external dependencies.

    The lifespan runs on TestClient creation and makes Supabase calls
    (resume_stuck_jobs, check_incomplete_embeddings). Mock these.
    """
    # Mock stuck jobs check (returns empty list)
    httpx_mock.add_response(
        url__regex=r".*/rest/v1/processing_jobs.*",
        json=[],
    )

    # Mock incomplete embeddings check (returns empty list)
    httpx_mock.add_response(
        url__regex=r".*/rest/v1/user_profiles.*",
        json=[],
    )

    from main import app
    with TestClient(app, raise_server_exceptions=False) as c:
        yield c
```

**Note on httpx_mock:** The existing conftest.py already sets env vars (SUPABASE_URL, SUPABASE_SERVICE_KEY, ANTHROPIC_API_KEY). The httpx_mock fixture from pytest-httpx intercepts httpx calls. But main.py also uses `anthropic.AsyncAnthropic` which may make calls — those are only in background tasks, not in endpoint handlers, so they won't be triggered by these tests.

**Tests to write:**

1. **test_health_returns_processors_available** — GET /health returns 200, response has processors_available=True, status="ok", service="soulprint-rlm"

2. **test_health_deep_returns_ok** — GET /health-deep returns 200 (mock Supabase calls). This test needs httpx_mock to handle the deep health check's DB/embedding/model checks. Mock all Supabase REST calls to return 200 with empty results, and mock Bedrock/embedding calls if needed. If this is too complex to mock reliably, test only that it returns without 500 (may return unhealthy if mocks don't perfectly match).

3. **test_status_endpoint** — GET /status returns 200

4. **test_process_full_v1_still_works** — POST /process-full with `{"user_id": "test-user", "storage_path": "user-exports/test/conv.json"}` returns 200 with status="processing". Mock the create_job Supabase call to return a job record.

5. **test_process_full_v2_works** — POST /process-full-v2 with `{"user_id": "test-user", "storage_path": "user-exports/test/conv.json"}` returns 200 with status="processing", version="v2". Mock the create_job Supabase call.

6. **test_process_full_v2_requires_storage_path** — POST /process-full-v2 with `{"user_id": "test-user"}` (no storage_path) returns 400.

7. **test_chat_endpoint_exists** — POST /chat with minimal body returns 400 or 422 (validation error) but NOT 404. This proves the endpoint is registered.

8. **test_query_endpoint_exists** — POST /query with minimal body returns 400 or 422 but NOT 404.

9. **test_all_get_endpoints_not_404** — Parametrized test for all GET endpoints: /health, /health-deep, /status, /test-embed, /test-patch. Verify none return 404.

10. **test_all_post_endpoints_not_404** — Parametrized test for all POST endpoints: /chat, /process-import, /query, /analyze, /create-soulprint, /process-full, /process-full-v2, /embed-chunks. Send minimal JSON body. Verify none return 404. (They may return 400/422 from validation, which is fine — proves endpoint exists.)

**For endpoint existence tests:** The goal is NOT to test business logic. It's to prove that the lifespan migration didn't accidentally break endpoint registration. A 400 or 422 (validation error) proves the endpoint exists and its handler ran. Only 404 would indicate a missing endpoint.

**httpx_mock considerations:**
- The `httpx_mock` fixture from pytest-httpx needs to handle ALL httpx requests that happen during lifespan startup AND during endpoint handling.
- For the simple existence tests, most endpoints will fail validation before making external calls, so minimal mocking is needed.
- For /process-full and /process-full-v2, the create_job function makes a Supabase call — mock it to return `[{"id": "test-job-123"}]` with status 201.
- Use `httpx_mock.add_response(url__regex=...)` with broad regex patterns to catch all Supabase calls.
- If pytest-httpx complains about unexpected requests, add catch-all: `httpx_mock.add_response()` (no URL filter) as a last resort.

**IMPORTANT:** Some endpoints (like /chat) use module-level variables and may fail at runtime due to missing AWS credentials or RLM setup. That's OK — a 500 error still proves the endpoint exists (it's not a 404). But prefer testing with minimal payloads that trigger validation errors (400/422) before hitting external services.

**Adapt based on what you discover:** If TestClient + lifespan + httpx_mock proves too complex for some endpoints (e.g., the asyncio.sleep in lifespan causes test hangs), simplify: test only the critical endpoints (health, status, process-full, process-full-v2) and test endpoint registration via route inspection instead of HTTP calls:

```python
def test_all_endpoints_registered():
    """Verify all 16 endpoints are registered (15 existing + 1 new v2)."""
    from main import app
    paths = [r.path for r in app.routes if hasattr(r, 'path')]
    expected = [
        "/health", "/health-deep", "/status",
        "/chat", "/query", "/analyze", "/create-soulprint",
        "/process-full", "/process-full-v2",
        "/process-import", "/embed-chunks",
        "/test-embed", "/test-patch",
        "/generate-soulprint/{user_id}",
        "/embedding-status/{user_id}",
        "/complete-embeddings/{user_id}",
    ]
    for ep in expected:
        assert ep in paths, f"Endpoint {ep} not registered"
```

This route inspection approach is simpler and equally valid for backwards compatibility testing.
  </action>
  <verify>
```bash
cd /home/drewpullen/clawd/soulprint-rlm && python -m pytest tests/test_endpoints.py -v
```
All tests should pass. Also verify existing tests still pass:
```bash
cd /home/drewpullen/clawd/soulprint-rlm && python -m pytest tests/ -v
```
  </verify>
  <done>
- test_endpoints.py exists with integration tests
- All endpoint tests pass (no 404s, no import errors)
- /process-full-v2 tests verify version="v2" in response
- /process-full-v2 returns 400 without storage_path
- /health returns processors_available=true
- Existing test suite (test_supabase_adapter.py, test_processors.py) still passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rollback procedure documentation</name>
  <files>/home/drewpullen/clawd/soulprint-rlm/ROLLBACK.md</files>
  <action>
Create ROLLBACK.md in the soulprint-rlm repo root with concrete rollback instructions.

**Content:**

```markdown
# Rollback Procedure

## When to Rollback

Rollback if ANY of these are true after deploying Phase 3 changes:
- /health endpoint returns 503 (processor import failure)
- Existing endpoints (/process-full, /chat, /query) return 500 errors
- Render dashboard shows service as unhealthy
- Users report errors in import or chat flows

## How to Rollback

### Step 1: Find the last known good commit

```bash
git log --oneline -10
```

Look for the commit BEFORE the Phase 3 changes. It will be the last commit from Phase 2 (processor tests or Dockerfile update).

### Step 2: Revert to last good commit

```bash
# Revert the most recent commit (if only 1 Phase 3 commit)
git revert HEAD --no-edit
git push origin main

# OR revert multiple commits (if 2+ Phase 3 commits)
# Find the merge base (last Phase 2 commit SHA)
git revert HEAD~N..HEAD --no-edit  # Where N is number of Phase 3 commits
git push origin main
```

### Step 3: Verify on Render

1. Go to Render dashboard: https://dashboard.render.com
2. Watch the deploy triggered by git push
3. Verify /health returns 200 after deploy completes
4. Verify /process-full still works (test with curl)

```bash
# Quick health check
curl https://soulprint-landing.onrender.com/health

# Verify v1 pipeline still works
curl -X POST https://soulprint-landing.onrender.com/process-full \
  -H "Content-Type: application/json" \
  -d '{"user_id": "test", "storage_path": "test"}'
```

### Step 4: Investigate

After rollback stabilizes production:
1. Check Render logs for error messages
2. Look for processor import errors in startup logs
3. Check if the issue is env vars, missing files, or code bugs
4. Fix in a new branch, test locally, then re-deploy

## What Gets Preserved During Rollback

- All database data (Supabase) is unaffected
- Processing jobs table tracks in-flight jobs for recovery
- v1 /process-full pipeline continues working
- No data loss — rollback only affects code deployment

## What Gets Lost During Rollback

- /process-full-v2 endpoint becomes unavailable
- Processor import validation in health check removed
- Lifespan startup validation removed (reverts to @app.on_event)
- Any in-flight v2 background tasks are killed on restart (tracked in processing_jobs for retry)
```

This document uses PROCEDURE, not specific SHAs (per research pitfall #5). The actual SHA is determined at rollback time using `git log`.
  </action>
  <verify>
```bash
test -f /home/drewpullen/clawd/soulprint-rlm/ROLLBACK.md && echo "ROLLBACK.md exists"
grep -c "git revert" /home/drewpullen/clawd/soulprint-rlm/ROLLBACK.md
```
Should exist and contain git revert commands.
  </verify>
  <done>
- ROLLBACK.md exists in soulprint-rlm repo root
- Contains step-by-step rollback procedure using git revert
- Documents when to rollback (failure indicators)
- Documents what gets preserved/lost during rollback
- Uses procedure (not hardcoded SHAs)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `python -m pytest tests/ -v` — All tests pass (adapter + processor + endpoint tests)
2. `cat ROLLBACK.md` — Contains rollback procedure with git revert commands
3. Total test count should be ~35+ (17 adapter + 15 processor + N endpoint tests)
</verification>

<success_criteria>
- All existing endpoints verified as still registered/working via tests
- /process-full-v2 tested with success and error cases
- /health tested for processors_available field
- ROLLBACK.md provides actionable recovery procedure
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-wire-new-endpoint/03-02-SUMMARY.md`
</output>
