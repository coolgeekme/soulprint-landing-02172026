---
phase: 01-schema-quick-pass-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/soulprint/prompts.ts
  - lib/soulprint/quick-pass.ts
  - app/api/import/process-server/route.ts
  - app/api/user/reset/route.ts
autonomous: true

must_haves:
  truths:
    - "After import processing, soul_md, identity_md, user_md, agents_md, and tools_md columns are populated with structured content"
    - "After import processing, soulprint_text contains concatenated sections with headers for backwards compatibility"
    - "After import processing, ai_name is set from the identity section"
    - "Quick pass uses Haiku 4.5 (HAIKU_45 model) via bedrockChatJSON"
    - "If quick pass fails, import still succeeds with a fallback placeholder soulprint"
    - "User reset nulls all 5 *_md columns alongside soulprint_text"
  artifacts:
    - path: "lib/soulprint/prompts.ts"
      provides: "System prompt template for quick pass"
      exports: ["QUICK_PASS_SYSTEM_PROMPT"]
    - path: "lib/soulprint/quick-pass.ts"
      provides: "Quick pass generation function"
      exports: ["generateQuickPass"]
    - path: "app/api/import/process-server/route.ts"
      provides: "Import pipeline with quick pass injection"
      contains: "generateQuickPass"
    - path: "app/api/user/reset/route.ts"
      provides: "Reset route that clears *_md columns"
      contains: "soul_md"
  key_links:
    - from: "lib/soulprint/quick-pass.ts"
      to: "lib/bedrock.ts"
      via: "bedrockChatJSON with HAIKU_45 model"
      pattern: "bedrockChatJSON.*HAIKU_45"
    - from: "lib/soulprint/quick-pass.ts"
      to: "lib/soulprint/sample.ts"
      via: "imports sampleConversations and formatConversationsForPrompt"
      pattern: "sampleConversations|formatConversationsForPrompt"
    - from: "lib/soulprint/quick-pass.ts"
      to: "lib/soulprint/types.ts"
      via: "validates response against quickPassResultSchema"
      pattern: "quickPassResultSchema"
    - from: "app/api/import/process-server/route.ts"
      to: "lib/soulprint/quick-pass.ts"
      via: "calls generateQuickPass after conversation parsing"
      pattern: "generateQuickPass"
    - from: "lib/soulprint/quick-pass.ts"
      to: "soulprint_text concatenation"
      via: "concatenates all 5 sections with markdown headers"
      pattern: "soulprint_text"
---

<objective>
Build the quick pass generation module and wire it into the import pipeline. After this plan, uploading a ChatGPT export will generate 5 structured context sections via Haiku 4.5 and save them to the database.

Purpose: This is the core deliverable of Phase 1 -- replacing the placeholder soulprint with real structured sections generated in ~30 seconds.
Output: Quick pass prompt, generation function, updated import pipeline, updated reset route.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-quick-pass-pipeline/01-RESEARCH.md
@.planning/phases/01-schema-quick-pass-pipeline/01-01-SUMMARY.md

@lib/bedrock.ts
@lib/soulprint/types.ts
@lib/soulprint/sample.ts
@app/api/import/process-server/route.ts
@app/api/user/reset/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quick pass prompt and generation module</name>
  <files>lib/soulprint/prompts.ts, lib/soulprint/quick-pass.ts</files>
  <action>
1. Create `lib/soulprint/prompts.ts`:

   Export `QUICK_PASS_SYSTEM_PROMPT` -- a system prompt that instructs Haiku 4.5 to analyze ChatGPT conversations and generate all 5 sections as a single JSON object. The prompt should:
   - Explain the purpose: building a structured personality profile for an AI assistant
   - Define each section's purpose and expected fields (matching the QuickPassResult interface from types.ts)
   - Instruct: base everything on EVIDENCE from conversations, don't speculate
   - Instruct: if information isn't available, use "not enough data" for that field
   - Instruct: respond with ONLY a JSON object, no other text
   - For `identity.ai_name`: generate a creative, personality-derived name (not generic like "Assistant")

   Use the prompt structure from the research file's "Quick Pass Prompt Design" section as the starting point. Ensure the JSON schema in the prompt exactly matches the TypeScript interfaces.

2. Create `lib/soulprint/quick-pass.ts`:

   Export `generateQuickPass(conversations: ParsedConversation[]): Promise<QuickPassResult | null>`

   Implementation:
   a. Import `sampleConversations`, `formatConversationsForPrompt` from `./sample`
   b. Import `bedrockChatJSON` from `@/lib/bedrock`
   c. Import `QuickPassResult`, `quickPassResultSchema` from `./types`
   d. Import `QUICK_PASS_SYSTEM_PROMPT` from `./prompts`
   e. Import `createLogger` from `@/lib/logger`
   f. Create logger: `createLogger('Soulprint:QuickPass')`

   Logic:
   - Sample conversations using `sampleConversations(conversations)`
   - Format using `formatConversationsForPrompt(sampledConversations)`
   - If formatted text is empty (no valid conversations), log warning and return null
   - Call `bedrockChatJSON<QuickPassResult>({ model: 'HAIKU_45', system: QUICK_PASS_SYSTEM_PROMPT, messages: [{ role: 'user', content: formattedText }], maxTokens: 8192, temperature: 0.7 })`
   - Validate response with `quickPassResultSchema.safeParse(result)`
   - If validation fails, log the Zod errors and return null (graceful degradation)
   - If validation succeeds, return the validated data
   - Wrap entire function in try-catch. On error, log and return null (never throw -- import must not fail because of quick pass)

   Also export `sectionsToSoulprintText(result: QuickPassResult): string`

   This function concatenates all 5 sections into a single markdown-formatted string for backwards compatibility with `soulprint_text`. Format:
   ```
   ## Communication Style & Personality
   {soul section as prose -- convert the JSON fields into readable text}

   ## Your AI Identity
   Name: {identity.ai_name}
   Archetype: {identity.archetype}
   Vibe: {identity.vibe}
   ...

   ## About You
   {user section fields as readable text}

   ## How I Operate
   {agents section as readable text}

   ## My Capabilities
   {tools section as readable text}
   ```

   Convert JSON structures to readable prose/lists. This text is what the chat route will see until Phase 3 refactors it.

   Also export `sectionToMarkdown(sectionName: string, data: Record<string, unknown>): string` helper that converts a section object to readable markdown (iterate keys, format arrays as bullet lists, strings as paragraphs).
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - `lib/soulprint/prompts.ts` exports QUICK_PASS_SYSTEM_PROMPT
  - `lib/soulprint/quick-pass.ts` exports generateQuickPass, sectionsToSoulprintText
  - generateQuickPass returns null on any failure (never throws)
  </verify>
  <done>
  `generateQuickPass` calls Haiku 4.5 with sampled conversations, validates response with Zod, and returns structured QuickPassResult or null. `sectionsToSoulprintText` converts the result to backwards-compatible markdown text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire quick pass into import pipeline and update reset route</name>
  <files>app/api/import/process-server/route.ts, app/api/user/reset/route.ts</files>
  <action>
1. Modify `app/api/import/process-server/route.ts`:

   Import `generateQuickPass` and `sectionsToSoulprintText` from `@/lib/soulprint/quick-pass`.

   Replace the placeholder soulprint block (lines ~291-316) with:

   ```typescript
   // === QUICK PASS: Generate structured context sections via Haiku 4.5 ===
   reqLog.info({ conversationCount: conversations.length }, 'Starting quick pass generation');
   const quickPassStart = Date.now();

   const quickPassResult = await generateQuickPass(conversations);

   const quickPassDuration = Date.now() - quickPassStart;
   reqLog.info({ quickPassDuration, success: !!quickPassResult }, 'Quick pass complete');

   // Build soulprint data
   let soulprintText: string;
   let aiName: string;
   let archetype: string;
   let soulMd: string | null = null;
   let identityMd: string | null = null;
   let userMd: string | null = null;
   let agentsMd: string | null = null;
   let toolsMd: string | null = null;

   if (quickPassResult) {
     // Quick pass succeeded -- use structured sections
     soulprintText = sectionsToSoulprintText(quickPassResult);
     aiName = quickPassResult.identity.ai_name || 'Soul';
     archetype = quickPassResult.identity.archetype || 'Your AI';

     // Store each section as JSON string in its *_md column
     soulMd = JSON.stringify(quickPassResult.soul);
     identityMd = JSON.stringify(quickPassResult.identity);
     userMd = JSON.stringify(quickPassResult.user);
     agentsMd = JSON.stringify(quickPassResult.agents);
     toolsMd = JSON.stringify(quickPassResult.tools);
   } else {
     // Quick pass failed -- use placeholder (user can still chat)
     soulprintText = `Analyzing ${totalMessages.toLocaleString()} messages across ${conversations.length.toLocaleString()} conversations. Your personalized SoulPrint is being created...`;
     aiName = 'Soul';
     archetype = 'Analyzing...';
     reqLog.warn('Quick pass failed, using placeholder soulprint');
   }

   const soulprint = {
     archetype,
     soulprint_text: soulprintText,
     stats,
     pending: !quickPassResult, // true if still needs generation
   };
   ```

   Then update the `adminSupabase.from('user_profiles').upsert(...)` call to include the new columns:
   ```typescript
   await adminSupabase.from('user_profiles').upsert({
     user_id: userId,
     soulprint: soulprint,
     soulprint_text: soulprintText,
     archetype,
     ai_name: aiName,
     soul_md: soulMd,
     identity_md: identityMd,
     user_md: userMd,
     agents_md: agentsMd,
     tools_md: toolsMd,
     import_status: 'quick_ready',
     import_error: null,
     total_conversations: conversations.length,
     total_messages: totalMessages,
     soulprint_generated_at: new Date().toISOString(),
     updated_at: new Date().toISOString(),
     raw_export_path: rawExportPath,
   }, { onConflict: 'user_id' });
   ```

   Keep the existing flow after this (update to 'processing', store raw JSON, fire-and-forget RLM call). The quick pass runs BETWEEN conversation parsing and RLM submission.

   Also update the response JSON to include `quickPassDuration` and `quickPassSuccess: !!quickPassResult` for observability.

2. Modify `app/api/user/reset/route.ts`:

   In the user_profiles update (step 5, around line 72-83), add the 5 `*_md` columns to be nulled:
   ```typescript
   const { error: profileError } = await adminSupabase
     .from('user_profiles')
     .update({
       import_status: 'none',
       embedding_status: null,
       total_chunks: 0,
       total_conversations: 0,
       total_messages: 0,
       soulprint_text: null,
       import_error: null,
       processing_started_at: null,
       soul_md: null,
       identity_md: null,
       user_md: null,
       agents_md: null,
       tools_md: null,
       ai_name: null,
     })
     .eq('user_id', userId);
   ```
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - `npm run build` succeeds (full Next.js build)
  - `app/api/import/process-server/route.ts` imports and calls `generateQuickPass`
  - `app/api/import/process-server/route.ts` saves all 5 `*_md` columns in the upsert
  - `app/api/user/reset/route.ts` nulls all 5 `*_md` columns plus `ai_name`
  - No existing tests broken: `npm test` passes
  </verify>
  <done>
  The import pipeline calls `generateQuickPass` after parsing conversations, saves structured sections to `*_md` columns, populates `soulprint_text` for backwards compatibility, and sets `ai_name` from the identity section. Reset route clears all section columns. Build passes.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds (full production build)
- `npm test` passes (all existing tests still work)
- `npm run lint` passes
- Import pipeline flow: parse conversations -> sample -> Haiku 4.5 -> save 5 sections + soulprint_text -> RLM fire-and-forget
- Reset flow: all *_md columns + soulprint_text + ai_name set to null
- Quick pass failure does NOT block import (graceful fallback to placeholder)
</verification>

<success_criteria>
- A full `npm run build` succeeds with the quick pass wired in
- The import route calls generateQuickPass and saves results to all 5 *_md columns
- soulprint_text is populated with concatenated readable sections
- ai_name is derived from identity section (not generated separately in chat route)
- Quick pass failure gracefully falls back to placeholder text
- User reset clears all structured section data
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-quick-pass-pipeline/01-02-SUMMARY.md`
</output>
