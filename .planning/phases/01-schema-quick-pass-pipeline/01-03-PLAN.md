---
phase: 01-schema-quick-pass-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - lib/soulprint/__tests__/sample.test.ts
  - lib/soulprint/__tests__/quick-pass.test.ts
autonomous: false

must_haves:
  truths:
    - "Sampling logic correctly ranks conversations by richness"
    - "Sampling respects token budget and conversation count caps"
    - "Quick pass generation handles Bedrock response parsing and Zod validation"
    - "Quick pass returns null on failure without throwing"
    - "sectionsToSoulprintText produces readable markdown with section headers"
  artifacts:
    - path: "lib/soulprint/__tests__/sample.test.ts"
      provides: "Unit tests for conversation sampling"
      contains: "sampleConversations"
    - path: "lib/soulprint/__tests__/quick-pass.test.ts"
      provides: "Unit tests for quick pass generation and section formatting"
      contains: "generateQuickPass"
  key_links:
    - from: "lib/soulprint/__tests__/sample.test.ts"
      to: "lib/soulprint/sample.ts"
      via: "imports and tests sampleConversations and formatConversationsForPrompt"
      pattern: "import.*sample"
    - from: "lib/soulprint/__tests__/quick-pass.test.ts"
      to: "lib/soulprint/quick-pass.ts"
      via: "imports and tests generateQuickPass and sectionsToSoulprintText"
      pattern: "import.*quick-pass"
---

<objective>
Write unit tests for the sampling and quick pass modules, then verify the full pipeline builds correctly. This validates that the core logic works before deploying to production.

Purpose: Catch bugs in sampling scoring, JSON parsing, Zod validation, and section formatting before a real user triggers the pipeline. The quick pass is a critical path -- it must not crash the import flow.
Output: Test files with comprehensive coverage of sampling and generation logic. Human verification that the pipeline compiles and is ready for production testing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-quick-pass-pipeline/01-01-SUMMARY.md
@.planning/phases/01-schema-quick-pass-pipeline/01-02-SUMMARY.md
@.planning/codebase/TESTING.md

@lib/soulprint/types.ts
@lib/soulprint/sample.ts
@lib/soulprint/quick-pass.ts
@lib/soulprint/prompts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write unit tests for sampling and quick pass modules</name>
  <files>lib/soulprint/__tests__/sample.test.ts, lib/soulprint/__tests__/quick-pass.test.ts</files>
  <action>
Use Vitest (the project's test framework). Follow existing test patterns from the codebase.

1. Create `lib/soulprint/__tests__/sample.test.ts`:

   Test `sampleConversations`:
   - Given 100 conversations of varying quality, returns at most 50
   - Given conversations with < 4 messages, filters them out
   - Given an empty array, returns empty array
   - Given 3 conversations all under 4 messages, returns empty array
   - Given 5 rich conversations within token budget, returns all 5
   - Given conversations exceeding token budget, stops when budget reached but ensures at least 5
   - Conversations with more messages and longer user messages score higher (verify ordering)

   Test `formatConversationsForPrompt`:
   - Includes conversation title and date in header
   - Formats messages as "Role: content" lines
   - Truncates messages longer than 2000 characters
   - Handles conversations with empty titles gracefully
   - Returns empty string for empty input array

   Use realistic test data: create helper function `makeConversation(overrides)` that generates ParsedConversation objects with configurable message counts and content lengths.

2. Create `lib/soulprint/__tests__/quick-pass.test.ts`:

   Mock `bedrockChatJSON` from `@/lib/bedrock` using `vi.mock`.

   Test `generateQuickPass`:
   - When Bedrock returns valid JSON matching QuickPassResult, returns parsed result
   - When Bedrock returns invalid JSON (missing fields), returns null (Zod validation catches it)
   - When Bedrock throws an error, returns null (never throws)
   - When given empty conversations array, returns null
   - Calls bedrockChatJSON with model 'HAIKU_45'

   Test `sectionsToSoulprintText`:
   - Returns a string containing section headers (e.g., "## Communication Style", "## Your AI Identity")
   - Includes all field values from each section
   - Handles array fields (personality_traits, behavioral_rules) as bullet lists
   - Returns non-empty string for a valid QuickPassResult
   - String length is reasonable (not empty, not absurdly long)

   Create a `MOCK_QUICK_PASS_RESULT` fixture object that satisfies the QuickPassResult interface with realistic data.
  </action>
  <verify>
  - `npm test` passes (all tests including new ones)
  - `npm test -- --reporter=verbose` shows all new test cases passing
  - At least 10 test cases total across both files
  </verify>
  <done>
  All unit tests pass. Sampling correctly filters, scores, and caps conversations. Quick pass handles success, validation failure, and Bedrock errors gracefully. sectionsToSoulprintText produces readable output with all sections.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Phase 1 quick pass pipeline:
  - Haiku 4.5 model constant in lib/bedrock.ts
  - TypeScript interfaces and Zod schema for 5 structured sections
  - Conversation sampling (scores by richness, respects token budget)
  - Quick pass generation (single Haiku 4.5 call, validates with Zod, graceful fallback)
  - Wired into import pipeline (replaces placeholder soulprint)
  - Reset route clears all *_md columns
  - Unit tests for sampling and generation
  </what-built>
  <how-to-verify>
  1. Run `npm run build` -- should succeed with zero errors
  2. Run `npm test` -- all tests should pass including new soulprint tests
  3. Review `lib/soulprint/` directory -- should contain types.ts, sample.ts, prompts.ts, quick-pass.ts, and __tests__/ directory
  4. Review the import pipeline change in `app/api/import/process-server/route.ts` -- look for the generateQuickPass call between conversation parsing and RLM submission
  5. IMPORTANT: The `tools_md` migration SQL needs to be run manually in Supabase SQL Editor before testing on production:
     - Open Supabase SQL Editor
     - Run: `ALTER TABLE public.user_profiles ADD COLUMN IF NOT EXISTS tools_md TEXT;`
  6. After running migration, test on production by uploading a ChatGPT export and checking if the user_profiles row has populated soul_md, identity_md, user_md, agents_md, tools_md columns
  </how-to-verify>
  <resume-signal>Type "approved" if build passes, tests pass, and code review looks good. Describe any issues otherwise.</resume-signal>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm test` passes with all new tests
- `npm run lint` passes
- New test files exist and cover core sampling and generation logic
- Human has reviewed the pipeline integration
</verification>

<success_criteria>
- All unit tests pass validating sampling logic, quick pass generation, and section formatting
- Human confirms the build succeeds and code is ready for production deployment
- The tools_md migration SQL is documented and ready for manual execution
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-quick-pass-pipeline/01-03-SUMMARY.md`
</output>
