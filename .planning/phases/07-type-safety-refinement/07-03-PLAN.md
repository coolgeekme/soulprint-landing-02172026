---
phase: 07-type-safety-refinement
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - tsconfig.json
  - app/api/import/process-server/route.ts
  - app/api/voice/process/route.ts
  - app/api/memory/synthesize/route.ts
  - app/api/cron/tasks/route.ts
  - app/api/branch/route.ts
  - app/api/pillars/stories/route.ts
  - app/api/debug/test-import/route.ts
  - app/api/embeddings/process/route.ts
  - app/api/admin/rechunk/route.ts
  - app/api/waitlist/confirm/route.ts
  - app/api/gamification/xp/route.ts
  - app/chat/page.tsx
  - app/pillars/page.tsx
  - lib/memory/learning.ts
  - lib/memory/facts.ts
  - lib/memory/query.ts
  - lib/search/perplexity.ts
  - lib/search/smart-search.ts
  - lib/bedrock.ts
autonomous: true

must_haves:
  truths:
    - "noUncheckedIndexedAccess is enabled in tsconfig.json"
    - "TypeScript build succeeds with zero type errors after enabling the flag"
    - "All 90+ Vitest tests pass after changes"
    - "All 8 Playwright E2E tests pass after changes"
  artifacts:
    - path: "tsconfig.json"
      provides: "TypeScript config with noUncheckedIndexedAccess enabled"
      contains: "noUncheckedIndexedAccess"
  key_links:
    - from: "tsconfig.json"
      to: "all source files"
      via: "compiler option enforcing undefined checks on indexed access"
      pattern: "noUncheckedIndexedAccess.*true"
---

<objective>
Enable `noUncheckedIndexedAccess` in tsconfig.json and fix all resulting type errors across the codebase.

Purpose: Prevent runtime undefined access bugs by making TypeScript enforce explicit undefined checks on all array element and object key lookups.

Output: `noUncheckedIndexedAccess: true` in tsconfig.json, zero type errors, all tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-type-safety-refinement/07-RESEARCH.md
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable noUncheckedIndexedAccess and catalog all type errors</name>
  <files>tsconfig.json</files>
  <action>
1. Add `"noUncheckedIndexedAccess": true` to `compilerOptions` in `tsconfig.json`.

2. Run `npx tsc --noEmit 2>&1 | head -200` to catalog the type errors. Expect 50-100+ errors based on research estimates.

3. Categorize errors by file and pattern:
   - Array element access (`arr[0]`, `arr[i]`) -- needs `?? defaultValue` or `if (x !== undefined)` check
   - Object key access (`obj[key]`) -- needs optional chaining or undefined check
   - Record/Map access -- needs undefined check

4. Do NOT fix errors in this task -- just enable the flag and catalog. Fixes come in Task 2.
  </action>
  <verify>
`grep "noUncheckedIndexedAccess" tsconfig.json` returns the line with `true`.
`npx tsc --noEmit 2>&1 | grep "error TS" | wc -l` shows the total error count (document this count).
  </verify>
  <done>
noUncheckedIndexedAccess enabled in tsconfig.json. Error count cataloged and categorized by file. Ready for systematic fixing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix all noUncheckedIndexedAccess type errors</name>
  <files>All files with indexed access errors (see known locations below)</files>
  <action>
Fix all type errors from enabling noUncheckedIndexedAccess. Use these patterns based on context:

**Pattern 1: Array first/last element access -- use optional chaining + nullish coalescing:**
```typescript
// Before: const first = arr[0];
// After:  const first = arr[0] ?? defaultValue;
// Or:     if (arr[0] !== undefined) { ... }
```

**Pattern 2: Loop index access -- typically safe, use non-null assertion only when loop guarantees bounds:**
```typescript
// for (let i = 0; i < arr.length; i++) -- arr[i] is guaranteed
// Use: const item = arr[i]!; // Loop bounds guarantee existence
// Or better: for (const item of arr) -- avoids indexed access entirely
```

**Pattern 3: Object key access -- use optional chaining:**
```typescript
// Before: const val = obj[key];
// After:  const val = obj[key]; if (val !== undefined) { ... }
```

**Known files with indexed access patterns to fix (from grep analysis):**

API Routes:
- `app/api/import/process-server/route.ts` line 96: `pathParts[0]` -- add undefined check or use destructuring with defaults
- `app/api/import/process-server/route.ts` line 218/220: `parts?.[0]` already uses optional chaining (may be fine)
- `app/api/voice/process/route.ts` line 63: `channels?.[0]?.alternatives?.[0]` -- already has optional chaining, may need downstream check
- `app/api/voice/process/route.ts` lines 87/89: `words[i]` and `words[i-1]` in loop -- bounds guaranteed by loop, use non-null assertion
- `app/api/memory/synthesize/route.ts` line 107: `content[0]?.text` -- already optional chaining, check result assignment
- `app/api/cron/tasks/route.ts` line 72: `choices?.[0]?.message?.content` -- already has optional chaining
- `app/api/branch/route.ts` line 40: `email?.split('@')[0]` -- add `?? user.id` fallback
- `app/api/pillars/stories/route.ts` lines 84/86: `pillarKeys[i]` and `PILLAR_NAMES[i]` in loop -- add undefined checks
- `app/api/debug/test-import/route.ts` lines 96-104: `conversations[0]` access -- add undefined check
- `app/api/embeddings/process/route.ts` lines 113-117: `embeddings[i]` and `chunks[i]` in parallel arrays -- add undefined checks
- `app/api/admin/rechunk/route.ts` lines 118-119, 200, 239: Loop indexed access -- add undefined checks where loop doesn't guarantee bounds
- `app/api/waitlist/confirm/route.ts` line 57: `email.split('@')[0]` -- add `?? ''` fallback
- `app/api/gamification/xp/route.ts` line 62/74: `.split('T')[0]` -- add `?? ''` fallback

Lib files:
- `lib/memory/learning.ts` line 106: `content[0]?.text` -- optional chain already present, check downstream
- `lib/memory/learning.ts` line 114: `jsonMatch[0]` -- add undefined check before JSON.parse
- `lib/memory/learning.ts` line 150: `embeddings[i]` in map -- bounds guaranteed by parallel array, add non-null assertion or undefined filter
- `lib/memory/facts.ts` lines 90/99: Same pattern as learning.ts -- `content[0]?.text` and `jsonMatch[0]`
- `lib/memory/query.ts` line 110: `result.embeddings.float[0]` -- add undefined check or throw if missing
- `lib/search/perplexity.ts` line 85: `choices?.[0]?.message?.content` -- already optional chaining
- `lib/search/smart-search.ts` line 75: `.sort((a, b) => a[1].timestamp - b[1].timestamp)` -- tuple access, may need type annotation
- `lib/bedrock.ts` line 191: `result.embedding` -- already validated by Zod in 07-01 (safeParse guarantees field exists)

Client pages:
- `app/chat/page.tsx` lines 302-303, 343-344: `match[1]`, `match[2]` regex captures -- add undefined checks or use `match?.[1]`
- `app/pillars/page.tsx` line 144: `sliderValue[0]` -- add `?? 50` default
- `app/import/page.tsx` lines 479-480: `files?.[0]` -- already uses optional chaining

**Strategy for each fix:**
1. If already using optional chaining (`?.`) -- may just need a nullish coalescing operator (`??`) for the assignment
2. If in a bounded loop (`for i < length`) -- use non-null assertion `!` with a comment explaining bounds guarantee
3. If accessing first element of an array that might be empty -- add explicit undefined check or default
4. Prefer `for...of` over indexed loops where practical
5. For `.split()[0]` patterns -- add `?? ''` fallback

Run `npx tsc --noEmit` after each batch of 5-10 files to verify progress. Continue until zero errors.
  </action>
  <verify>
Run `npx tsc --noEmit` -- exits 0 with zero type errors.
Run `npm test` -- all 90+ Vitest tests pass.
Run `npx playwright test` -- all 8 E2E tests pass (run only if build succeeds).
  </verify>
  <done>
All indexed access patterns have explicit undefined handling. TypeScript build succeeds with `noUncheckedIndexedAccess: true`. All Vitest and Playwright tests pass. Zero type errors in the entire codebase.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` exits 0 with zero type errors (with noUncheckedIndexedAccess enabled)
2. `npm test` -- all 90+ Vitest tests pass
3. `npx playwright test` -- all 8 E2E tests pass
4. `grep "noUncheckedIndexedAccess" tsconfig.json` shows `true`
5. `npm run build` succeeds (Next.js production build)
</verification>

<success_criteria>
- `noUncheckedIndexedAccess: true` is set in tsconfig.json compilerOptions
- TypeScript build (`npx tsc --noEmit`) succeeds with zero errors
- All 90+ Vitest unit/integration tests pass
- All 8 Playwright E2E tests pass
- Next.js build (`npm run build`) succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-type-safety-refinement/07-03-SUMMARY.md`
</output>
